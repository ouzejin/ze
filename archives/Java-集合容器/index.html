<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,ZE,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="ze &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="ze &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/591f9f7764a8fd2466b8ba7b37e37a9e.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>Java-集合容器 - ze</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="容器总览" />
<meta property="og:title" content="Java-集合容器 - ze" />
<meta property="og:description" content="容器总览" />
<meta property="og:site_name" content="ze" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/Java-集合容器/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-08-23T20:37:41-00.00" />
<meta name="twitter:title" content="Java-集合容器 - ze" />
<meta name="twitter:description" content="容器总览" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/avatar.png">ze</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.ze.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.ze.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/ouzejin" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/ouzejin" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class=" "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/Redis/">Redis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Redis实现高并发秒杀系统/">Redis实现高并发秒杀系统</a></li><li class=""><a href="/archives/Redis部署与基本使用/">Redis部署与基本使用</a></li><li class=""><a href="/archives/Redis实现单点登录/">Redis实现单点登录</a></li><li class=""><a href="/archives/Redis理论学习笔记/">Redis理论学习笔记</a></li></ul></div><li class=""><a href="/archives/SQL学习笔记/">SQL学习笔记</a></li><li class=""><a href="/archives/Mysql理论学习笔记/">Mysql理论学习笔记</a></li><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class="open "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-时间处理/">Java-时间处理</a></li><li class=""><a href="/archives/Java-反射/">Java-反射</a></li><li class=""><a href="/archives/Java-JDK8新特性/">Java-JDK8新特性</a></li><li class=""><a href="/archives/Java-IO/">Java-IO</a></li><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class="current"><a href="/archives/Java-集合容器/">Java-集合容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class=""><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/腾讯云学习笔记/">腾讯云学习笔记</a></li><li class=""><a href="/archives/面试题整理/">面试题整理</a></li><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class=" "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Swagger使用/">Swagger使用</a></li><li class=""><a href="/archives/Lombok使用/">Lombok使用</a></li><li class=""><a href="/archives/Maven中依赖的scope总结/">Maven中依赖的scope总结</a></li><li class=""><a href="/archives/Devtools对Springboot热部署/">Devtools对Springboot热部署</a></li><li class=""><a href="/archives/IDEA配置Run Dashboard/">IDEA配置Run Dashboard</a></li><li class=""><a href="/archives/IDEA初始化SpringBoot项目+逆向工程+配置/">IDEA初始化SpringBoot项目+逆向工程+配置</a></li><li class=""><a href="/archives/EasyExcel导入导出Excel/">EasyExcel导入导出Excel</a></li><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/Mybatis/">Mybatis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Mybatis学习笔记/">Mybatis学习笔记</a></li><li class=""><a href="/archives/Mybatis逆向工程&Example类使用/">Mybatis逆向工程&Example类使用</a></li></ul></div><li class=""><a href="/archives/HttpServletrequest与HttpServletResponse/">HttpServletrequest与HttpServletResponse</a></li><li class=""><a href="/archives/SpringMVC基础&面试/">SpringMVC基础&面试</a></li><li class=""><a href="/archives/SpringMVC注解/">SpringMVC注解</a></li><li class=""><a href="/archives/Spring基础&面试/">Spring基础&面试</a></li><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/前端/">前端</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/JavaScript面试题/">JavaScript面试题</a></li><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法基础笔记/">数据结构&算法基础笔记</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.ze.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.ze.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/ouzejin">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/ouzejin">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">Java-集合容器</h1>
        <p class="post-meta">
            <time>August 23 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/Java/">#Java</a>
                </span>
                
                <span>
                    <a href="/tag/Java-集合容器/">#Java-集合容器</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h1>容器总览</h1>
<p>注</p>
<blockquote><ul>
<li>虚线空心三角：继承，例如<code>AbstractList</code>继承<code>List</code></li>
<li>实线空心三角：实现，例如<code>ArrayList</code>实现<code>AbstractList</code></li>
</ul>
<ul>
<li>小虚线：接口</li>
<li>长虚线：抽象类</li>
<li>实现：实现类</li>
</ul>
</blockquote>
<p><figure><img data-width="959" data-height="912" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/40eb958aebc6e5e06c8b4f0afb334cb5.jpg" alt="" /></figure></p>
<p><figure><img data-width="-1" data-height="-1" src="images/Java容器/Java集合框架体系.png" alt="" /></figure></p>
<p><figure><img data-width="801" data-height="810" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/fbbb5098a2e2b5c19e24ba6c4c1118e3.png" alt="" /></figure></p>
<p><figure><img data-width="785" data-height="142" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/cd5fe982e2ae398a3ce27e2507edef16.png" alt="" /></figure></p>
<h2>常用集合方法</h2>
<p>参考</p>
<blockquote><p><a href="https://wiki.lifeisgg.online/archives/Java%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB">https://wiki.lifeisgg.online/archives/Java%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB</a></p>
</blockquote>
<h1>1. List</h1>
<h2>1.1 ArrayList</h2>
<p>参考</p>
<blockquote><p>ArrayList方法原理：<a href="https://www.cnblogs.com/lierabbit/p/8383683.html">https://www.cnblogs.com/lierabbit/p/8383683.html</a></p>
</blockquote>
<h3>构造方法</h3>
<ul>
<li>无参构造方法</li>
<li>有参构造方法</li>
<li>指定集合</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">()</span><span class="c1">//无参构造方法</span>
<span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">)</span><span class="err">；</span><span class="c1">//有参构造方法</span>
<span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span><span class="c1">//指定集合</span>

<span class="cm">/**</span>
<span class="cm">* 默认初始容量大小为10</span>
<span class="cm">*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CAPACITY</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="cm">/**默认空数组*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="o">=</span> <span class="p">{};</span>
</pre></div>
<p><strong>无参构造方法</strong></p>
<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong></p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Shared empty array instance used for default sized empty instances. We</span>
<span class="cm">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span>
<span class="cm">     * first element is added.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="cm">/**</span>
<span class="cm">     * Constructs an empty list with an initial capacity of ten.</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<p><strong>有参指定大小构造方法</strong></p>
<ul>
<li>当指定的初始容量大于0，初始化指定大小的数组</li>
<li>当指定的初始容量等于0，初始化空数组</li>
<li>当指定的初始容量小于0，抛出IllegalArgumentException异常</li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Shared empty array instance used for empty instances.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">EMPTY_ELEMENTDATA</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="cm">/**</span>
<span class="cm">     * Constructs an empty list with the specified initial capacity.</span>
<span class="cm">     *</span>
<span class="cm">     * @param  initialCapacity  the initial capacity of the list</span>
<span class="cm">     * @throws IllegalArgumentException if the specified initial capacity</span>
<span class="cm">     *         is negative</span>
<span class="cm">     */</span>


    <span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">initialCapacity</span><span class="o">]</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="n">EMPTY_ELEMENTDATA</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Illegal Capacity: &quot;</span><span class="o">+</span>
                                               <span class="n">initialCapacity</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<p><strong>指定集合</strong></p>
<p>当指定集合不为空即长度不为0，则复制该集合，否则初始化一个空数组</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Constructs a list containing the elements of the specified</span>
<span class="cm">     * collection, in the order they are returned by the collection&#39;s</span>
<span class="cm">     * iterator.</span>
<span class="cm">     *</span>
<span class="cm">     * @param c the collection whose elements are to be placed into this list</span>
<span class="cm">     * @throws NullPointerException if the specified collection is null</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">elementData</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="na">toArray</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">=</span> <span class="n">elementData</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">elementData</span><span class="p">.</span><span class="na">getClass</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Object</span><span class="o">[]</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
                <span class="n">elementData</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">Object</span><span class="o">[]</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// replace with empty array.</span>
            <span class="k">this</span><span class="p">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="n">EMPTY_ELEMENTDATA</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<h3>E get(int index) ：获取index位置的元素</h3>
<p>首先判断index是否越界，这里并没有判断是否小于0，因为下标小于0时数组会抛出异常。越界则抛出IndexOutOfBoundsException异常，反之返回数组对应index位置的元素</p>
<div class="highlight"><pre><span></span><span class="c1">// Positional Access Operations</span>
    <span class="c1">// 返回index下标的元素且强制转化为E（List&lt;E&gt;中的E）类型</span>
    <span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
    <span class="n">E</span> <span class="nf">elementData</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Returns the element at the specified position in this list.</span>
<span class="cm">     *</span>
<span class="cm">     * @param  index index of the element to return</span>
<span class="cm">     * @return the element at the specified position in this list</span>
<span class="cm">     * @throws IndexOutOfBoundsException {@inheritDoc}</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 检查index是否越界</span>
        <span class="n">rangeCheck</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="c1">// 返回index下标的元素</span>
        <span class="k">return</span> <span class="n">elementData</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Checks if the given index is in range.  If not, throws an appropriate</span>
<span class="cm">     * runtime exception.  This method does *not* check if the index is</span>
<span class="cm">     * negative: It is always used immediately prior to an array access,</span>
<span class="cm">     * which throws an ArrayIndexOutOfBoundsException if index is negative.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">rangeCheck</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 检查index是否大于等于size（数组的元素数量），因为数组下标从0开始计算，所以也不能等于元素数量</span>
        <span class="c1">// 这里没有检查index &lt; 0的情况，因为index &lt; 0时数组会自动抛出异常，所以并未检查index&lt;0的情况</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="p">(</span><span class="n">outOfBoundsMsg</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Constructs an IndexOutOfBoundsException detail message.</span>
<span class="cm">     * Of the many possible refactorings of the error handling code,</span>
<span class="cm">     * this &quot;outlining&quot; performs best with both server and client VMs.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="nf">outOfBoundsMsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Index: &quot;</span><span class="o">+</span><span class="n">index</span><span class="o">+</span><span class="s">&quot;, Size: &quot;</span><span class="o">+</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>E set(int index, E element)  ：设置（覆盖）index位置的元素</h3>
<p>和get一样先判断index（下标）是否越界，不越界则先获取原来index位置上的元素，接着设置（覆盖）index位置上的元素，然后返回原来的元素，反之抛出IndexOutOfBoundsException异常</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Replaces the element at the specified position in this list with</span>
<span class="cm">     * the specified element.</span>
<span class="cm">     *</span>
<span class="cm">     * @param index index of the element to replace</span>
<span class="cm">     * @param element element to be stored at the specified position</span>
<span class="cm">     * @return the element previously at the specified position</span>
<span class="cm">     * @throws IndexOutOfBoundsException {@inheritDoc}</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">E</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rangeCheck</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>

        <span class="n">E</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">elementData</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>boolean add(E e)  ：添加一个元素到列表尾/扩容机制</h3>
<p><strong>参考</strong></p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/dengrongzhang/p/9371551.html">https://www.cnblogs.com/dengrongzhang/p/9371551.html</a></li>
<li><a href="https://blog.csdn.net/zymx14/article/details/78324464">https://blog.csdn.net/zymx14/article/details/78324464</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md</a></li>
</ul>
</blockquote>
<p>添加一个元素到列表尾，当列表容量不足时自动扩容（通常是扩容至原来的1.5倍），添加成功返回true 。如果是新创建的对象且调用的无参构造方法，初始化时是将空数组<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>赋给elementData，在第一次调用add方法时才会扩容，一般是默认值<code>DEFAULT_CAPACITY = 10</code></p>
<h4>流程</h4>
<ul>
<li>第一步：调用<code>ensureCapacityInternal(size + 1)</code>方法</li>
<li>第二步：调用 <code>calculateCapacity(elementData, minCapacity)</code> 方法计算返回需要扩容的最小值</li>
<li>第三步：调用<code>ensureExplicitCapacity()</code>方法判断扩容的最小值是否大于数组的长度，此时<code>minCapacity</code>为调用<code>calculateCapacity</code>传过来的最后计算得出的最小容量。大于则继续调用<strong>grow(minCapacity)</strong>方法，否则直接 <code>elementData[size++] = e</code>;</li>
<li>第四步：调用<code>grow()</code>方法进行扩容。先<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>;计算扩容<code>1.5倍</code>后再与<code>minCapacity</code>对比，如果还是比<code>minCapacity</code>小就直接<code>newCapacity = minCapacity</code>; 之后再将<code>newCapacity</code>与<code>MAX_ARRAY_SIZE</code>对比，如果比<code>MAX_ARRAY_SIZE</code>大那就调用<code>hugeCapacity(minCapacity)</code>;重新计算大小，最后<code>elementData = Arrays.copyOf(elementData, newCapacity)</code>;完成扩容，最后再将加的对象赋值给<code>elementData[size] , size++</code></li>
</ul>
<h4>第一步：调用<code>ensureCapacityInternal(size + 1)</code>方法</h4>
<p><code>minCapacity = size + 1</code>即为所需最小容量，调用此方法时会先调用<code>calculateCapacity(elementData, minCapacity)</code>去计算所需最小容量，之后作为参数去调用<code>ensureExplicitCapacity</code>去与当前elementdata数组的长度<code>elementdata.length</code>比较看是否需要调用<code>grow()</code>去扩容。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Appends the specified element to the end of this list.</span>
<span class="cm">     *</span>
<span class="cm">     * @param e element to be appended to this list</span>
<span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 检查当前容量是否还可以容纳一个元素，不够则扩容</span>
        <span class="n">ensureCapacityInternal</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Increments modCount!!</span>
        <span class="c1">// 添加到数组末尾</span>
        <span class="c1">// 这个语句可以分解为</span>
        <span class="c1">// elementData[size] = e;</span>
        <span class="c1">// size += 1;</span>
        <span class="n">elementData</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureCapacityInternal</span><span class="p">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ensureExplicitCapacity</span><span class="p">(</span><span class="n">calculateCapacity</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">minCapacity</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
<blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
</blockquote>
<h4>第二步：调用 <code>calculateCapacity(elementData, minCapacity)</code> 方法</h4>
<p>计算默认容量<code>DEFAULT_CAPACITY = 10</code>和当前<code>minCapacity = size + 1</code>的最大值。当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Default initial capacity.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CAPACITY</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// 默认容量为10</span>

 <span class="c1">// 如果数据等于默认数据，返回默认容量和minCapacity（所需容量最小值）的最大值，反之返回所需容量最小值</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateCapacity</span><span class="p">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">elementData</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">elementData</span> <span class="o">==</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">DEFAULT_CAPACITY</span><span class="p">,</span> <span class="n">minCapacity</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">minCapacity</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * The maximum size of array to allocate.</span>
<span class="cm">     * Some VMs reserve some header words in an array.</span>
<span class="cm">     * Attempts to allocate larger arrays may result in</span>
<span class="cm">     * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="cm">     */</span>
</pre></div>
<h4>第三步：调用<code>ensureExplicitCapacity()</code>方法看是否需要扩容</h4>
<ul>
<li>当我们要 add 进第1个元素到 ArrayList 时，<code>elementData.length</code> 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity为10)</code> 方法。</li>
<li>当add第2个元素时，<code>minCapacity</code> 为2，此时<code>elementData.length</code>(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。直到添加第11个元素，<code>minCapacity(为11)</code>比<code>elementData.length（为10）</code>要大。进入<code>grow(minCapacity为11)</code>方法进行扩容</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureExplicitCapacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">modCount</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 操作数+1</span>

        <span class="c1">// overflow-conscious code</span>
        <span class="c1">// 如果所需容量最小值大于实际数组的长度就扩大实际数组容量</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minCapacity</span> <span class="o">-</span> <span class="n">elementData</span><span class="p">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">grow</span><span class="p">(</span><span class="n">minCapacity</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<h4>第四步：调用<code>grow()</code>方法进行扩容</h4>
<ul>
<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>
<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>
<li>以此类推······</li>
</ul>
<p>之所以每次扩容原来的<code>1.5倍</code>，是为了不让每次调用<code>add()</code>方法都去扩容然后复制数组</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Increases the capacity to ensure that it can hold at least the</span>
<span class="cm">     * number of elements specified by the minimum capacity argument.</span>
<span class="cm">     *</span>
<span class="cm">     * @param minCapacity the desired minimum capacity</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">grow</span><span class="p">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// overflow-conscious code</span>
        <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">elementData</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
        <span class="c1">// 新的容量为旧的容量的1.5倍</span>
        <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">+</span> <span class="p">(</span><span class="n">oldCapacity</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 如果扩充容量后还是不够，则新的容量等于所需容量最小值（一般就是数组实际元素个数）</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newCapacity</span> <span class="o">-</span> <span class="n">minCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">minCapacity</span><span class="p">;</span>
        <span class="c1">// 如果新的容量大于数组最大容量，再调用hugeCapacity计算新的容量</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newCapacity</span> <span class="o">-</span> <span class="n">MAX_ARRAY_SIZE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">hugeCapacity</span><span class="p">(</span><span class="n">minCapacity</span><span class="p">);</span>
        <span class="c1">// minCapacity is usually close to size, so this is a win:</span>
        <span class="c1">// 复制原来的数据到新的数组，数组容量为新的容量</span>
        <span class="n">elementData</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">newCapacity</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hugeCapacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// overflow</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">OutOfMemoryError</span><span class="p">();</span>
        <span class="c1">// 大于数组最大容量返回Integer最大值，反之返回数组最大容量</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">minCapacity</span> <span class="o">&gt;</span> <span class="n">MAX_ARRAY_SIZE</span><span class="p">)</span> <span class="o">?</span>
                <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span> <span class="p">:</span>
                <span class="n">MAX_ARRAY_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_ARRAY_SIZE</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1">// 数组最大容量为Integer最大值再减8</span>
</pre></div>
<h3>void add(int index, E element) ：在index处放置元素</h3>
<p>将elementData数组从index开始后面的元素往后移一位，接着在index处放置元素</p>
<p><strong>模拟添加数据(lierabbit)到index=4过程如下：</strong></p>
<p><figure><img data-width="1826" data-height="425" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/0729abe0cfcb74f571929f267a12ccfb.jpg" alt="" /></figure></p>
<ul>
<li>在此列表中的指定位置插入指定的元素。 </li>
<li>先调用 <code>rangeCheckForAdd</code> 对index进行界限检查；然后调用 <code>ensureCapacityInternal</code> 方法保证<code>capacity</code>足够大；</li>
<li>再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Inserts the specified element at the specified position in this</span>
<span class="cm">     * list. Shifts the element currently at that position (if any) and</span>
<span class="cm">     * any subsequent elements to the right (adds one to their indices).</span>
<span class="cm">     *</span>
<span class="cm">     * @param index index at which the specified element is to be inserted</span>
<span class="cm">     * @param element element to be inserted</span>
<span class="cm">     * @throws IndexOutOfBoundsException {@inheritDoc}</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">E</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 检查下标是否越界</span>
        <span class="n">rangeCheckForAdd</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="c1">// 检查当前容量是否还可以在容纳一个元素，不够则扩容</span>
        <span class="n">ensureCapacityInternal</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Increments modCount!!</span>
        <span class="c1">// 将elementData从index开始后面的元素往后移一位</span>
        <span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">elementData</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">size</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
        <span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * A version of rangeCheck used by add and addAll.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">rangeCheckForAdd</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 当index等于size时相当于添加元素到列表尾</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="p">(</span><span class="n">outOfBoundsMsg</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
<h3>ensureCapacity(int minCapacity)：自主扩增容量</h3>
<p>在使用add()方法增加新的元素时，如果要增加的数据量很大，应该使用<code>ensureCapacity()</code>方法，该方法的作用是预先设置Arraylist的大小，这样可以大大提高初始化速度。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span>
<span class="cm">     *</span>
<span class="cm">     * @param   minCapacity   所需的最小容量</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">minExpand</span> <span class="o">=</span> <span class="p">(</span><span class="n">elementData</span> <span class="o">!=</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="p">)</span><span class="o">?</span> <span class="mi">0</span><span class="p">:</span> <span class="n">DEFAULT_CAPACITY</span><span class="p">;</span>
            <span class="c1">// any size if not default element table            </span>
            <span class="c1">// larger than default for default empty table. It&#39;s already</span>
            <span class="c1">// supposed to be at default size.</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">minCapacity</span> <span class="o">&gt;</span> <span class="n">minExpand</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ensureExplicitCapacity</span><span class="p">(</span><span class="n">minCapacity</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<p>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数。例如：</p>
<p>未提前使用 <code>ensureCapacity</code> 前</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EnsureCapacityTest</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;使用ensureCapacity方法前：&quot;</span><span class="o">+</span><span class="p">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">));</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>结果：使用<code>ensureCapacity</code>方法前：2158</p>
<p>使用 <code>ensureCapacity</code> 后</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EnsureCapacityTest</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="kt">long</span> <span class="n">startTime1</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
        <span class="n">list</span><span class="p">.</span><span class="na">ensureCapacity</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="c1">//此处调用后</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">long</span> <span class="n">endTime1</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;使用ensureCapacity方法后：&quot;</span><span class="o">+</span><span class="p">(</span><span class="n">endTime1</span> <span class="o">-</span> <span class="n">startTime1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>结果：使用<code>ensureCapacity</code>方法后：1773</p>
<h3>数组复制/扩容的两个方法</h3>
<h4>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</h4>
<p>将数组<code>src</code>从<code>srcPos</code>后的元素复制到目标数组<code>dest</code>的<code>destPos</code>起点开始，复制<code>length</code>个</p>
<blockquote><ul>
<li><code>src</code> -这是源数组. </li>
<li><code>srcPos</code> -这是源数组中的起始位置。</li>
<li><code>dest</code> -这是目标数组。</li>
<li><code>destPos</code> -这是目标数据中的起始位置。</li>
<li><code>length</code> -- 这是一个要复制的数组元素的数目。</li>
</ul>
</blockquote>
<h4>Arrays.copyOf()</h4>
<div class="highlight"><pre><span></span><span class="n">elementData</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">newCapacity</span><span class="p">);</span>
</pre></div>
<h4>区别</h4>
<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h3>boolean addAll(Collection&lt;? extends E&gt; c) : 添加一个集合里的所有元素到列表尾</h3>
<p>将要添加的集合变为数组，然后将其复制到elementData数组末尾</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Appends all of the elements in the specified collection to the end of</span>
<span class="cm">     * this list, in the order that they are returned by the</span>
<span class="cm">     * specified collection&#39;s Iterator.  The behavior of this operation is</span>
<span class="cm">     * undefined if the specified collection is modified while the operation</span>
<span class="cm">     * is in progress.  (This implies that the behavior of this call is</span>
<span class="cm">     * undefined if the specified collection is this list, and this</span>
<span class="cm">     * list is nonempty.)</span>
<span class="cm">     *</span>
<span class="cm">     * @param c collection containing elements to be added to this list</span>
<span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span>
<span class="cm">     * @throws NullPointerException if the specified collection is null</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="na">toArray</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">numNew</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
        <span class="c1">// 检查当前容量是否还可以在容纳a数组的元素，不够则扩容</span>
        <span class="n">ensureCapacityInternal</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">numNew</span><span class="p">);</span>  <span class="c1">// Increments modCount</span>
        <span class="c1">// 将a数组里的元素添加到elementData末尾</span>
        <span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elementData</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">numNew</span><span class="p">);</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">numNew</span><span class="p">;</span>
        <span class="c1">// a数组不为空（长度不为0）时返回true，反之false</span>
        <span class="k">return</span> <span class="n">numNew</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>int indexOf(Object o)  ：查找o元素在列表第一次出现的位置</h3>
<p>ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，如果使用<strong>null.equals(Object o)</strong>会报错空指针，因此必须对null单独查找。如果未找到该元素则返回-1</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Returns the index of the first occurrence of the specified element</span>
<span class="cm">     * in this list, or -1 if this list does not contain the element.</span>
<span class="cm">     * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that</span>
<span class="cm">     * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span>
<span class="cm">     * or -1 if there is no such index.</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//元素可以为null，如果为null返回null的下标</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">elementData</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="kc">null</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">elementData</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 没有找到对应的元素返回-1</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>E remove(int index)  ：删除index位置上的元素</h3>
<p>模拟删除index=4（值为lierabbit）过程如下</p>
<p><figure><img data-width="1461" data-height="346" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/c7e5719cafc7cb3b57b7a33bcd8b681d.jpg" alt="" /></figure></p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Removes the element at the specified position in this list.</span>
<span class="cm">     * Shifts any subsequent elements to the left (subtracts one from their</span>
<span class="cm">     * indices).</span>
<span class="cm">     *</span>
<span class="cm">     * @param index the index of the element to be removed</span>
<span class="cm">     * @return the element that was removed from the list</span>
<span class="cm">     * @throws IndexOutOfBoundsException {@inheritDoc}</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 检查下标是否越界</span>
        <span class="n">rangeCheck</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>

        <span class="n">modCount</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 操作数+1</span>
        <span class="n">E</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">elementData</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>  <span class="c1">// 获取index位置上的元素</span>

        <span class="kt">int</span> <span class="n">numMoved</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 需要往前移动几个位置</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numMoved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">// 从index + 1开始，往后的元素向前移动1个位置</span>
            <span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">elementData</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                    <span class="n">numMoved</span><span class="p">);</span>
        <span class="c1">// 将数组末尾元素置空</span>
        <span class="n">elementData</span><span class="o">[--</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// clear to let GC do its work</span>

        <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>boolean remove(Object o)  ：删除o元素</h3>
<p>通过寻找o元素，可以获得其下标，再根据下标删除o元素</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">     * Removes the first occurrence of the specified element from this list,</span>
<span class="cm">     * if it is present.  If the list does not contain the element, it is</span>
<span class="cm">     * unchanged.  More formally, removes the element with the lowest index</span>
<span class="cm">     * &lt;tt&gt;i&lt;/tt&gt; such that</span>
<span class="cm">     * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;</span>
<span class="cm">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span>
<span class="cm">     * contained the specified element (or equivalently, if this list</span>
<span class="cm">     * changed as a result of the call).</span>
<span class="cm">     *</span>
<span class="cm">     * @param o element to be removed from this list, if present</span>
<span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 元素可以为null，分开搜索o</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">fastRemove</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">fastRemove</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 没有找到返回false</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Private remove method that skips bounds checking and does not</span>
<span class="cm">     * return the value removed.</span>
<span class="cm">     */</span>
    <span class="c1">// 由于已经找到元素，则元素必定存在，则index必定合理，所以不需要在检查index是否越界</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">fastRemove</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">modCount</span><span class="o">++</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">numMoved</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numMoved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">elementData</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">elementData</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                    <span class="n">numMoved</span><span class="p">);</span>
        <span class="n">elementData</span><span class="o">[--</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// clear to let GC do its work</span>
    <span class="p">}</span>
</pre></div>
<h3>forEach(Consumer&lt;? super E&gt; action) ：遍历列表</h3>
<p>这里可以看到<strong>modCount</strong>的用处，当<strong>modCount</strong>发生改变后，立刻抛出<strong>ConcurrentModificationException</strong>异常。通过之前的分析可以知道当列表内容被修改时<strong>modCount</strong>会增加。也就是说如果在遍历<strong>ArrayList</strong>的过程中有其他线程修改了<strong>ArrayList</strong>，那么将抛出<strong>ConcurrentModificationException</strong>异常</p>
<div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//操作数</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="p">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 确保不为空</span>
        <span class="n">Objects</span><span class="p">.</span><span class="na">requireNonNull</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="p">;</span>
        <span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
        <span class="kd">final</span> <span class="n">E</span><span class="o">[]</span> <span class="n">elementData</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">[]</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="na">elementData</span><span class="p">;</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">modCount</span> <span class="o">==</span> <span class="n">expectedModCount</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">action</span><span class="p">.</span><span class="na">accept</span><span class="p">(</span><span class="n">elementData</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">ConcurrentModificationException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">requireNonNull</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h2>LinkedList</h2>
<h2>区别</h2>
<h3>ArrayList与List的区别</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/zcscnn/p/7743507.html">https://www.cnblogs.com/zcscnn/p/7743507.html</a></li>
</ul>
</blockquote>
<p>List是一个接口，而ListArray是一个类。ArrayList继承并实现了List。</p>
<p>因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。</p>
<div class="highlight"><pre><span></span><span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">();</span><span class="c1">//是错误的用法</span>
<span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="p">();</span><span class="c1">//正确</span>
</pre></div>
<p>这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 而ArrayList list=newArrayList();</p>
<p>创建一对象则保留了ArrayList的所有属性和方法。</p>
<h3>Arraylist 与 LinkedList 区别?</h3>
<p><figure><img data-width="779" data-height="659" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/5253c5af82499f1755864fa8573a5d3a.png" alt="" /></figure></p>
<h3>ArrayList 与 Vector 区别呢?为什么要⽤Arraylist取代Vector呢？</h3>
<p><figure><img data-width="784" data-height="110" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/672f2e3d03eb1d3a1431ded823c04b9b.png" alt="" /></figure></p>
<h1>2. Set</h1>
<h2>2.1 HashSet</h2>
<p><strong>HashSet</strong>实现<strong>Set</strong>接口，由哈希表（实际上是一个<strong>HashMap</strong>实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。对于<strong>HashSet</strong>而言，它是基于<strong>HashMap</strong>实现的，HashSet底层使用<strong>HashMap</strong>来保存所有元素，因此<strong>HashSet</strong> 的实现比较简单，相关<strong>HashSet</strong>的操作，基本上都是直接调用底层<strong>HashMap</strong>的相关方法来完成， <strong>HashSet</strong>的源代码如下：</p>
<h3>HashSet与HashMap区别</h3>
<p><figure><img data-width="817" data-height="386" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/6ed857e6affc4d930cd4a12f356d88a7.png" alt="" /></figure></p>
<h3>构造器</h3>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>  
    <span class="kd">extends</span> <span class="n">AbstractSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>  
    <span class="kd">implements</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Cloneable</span><span class="p">,</span> <span class="n">java</span><span class="p">.</span><span class="na">io</span><span class="p">.</span><span class="na">Serializable</span>  
<span class="p">{</span>  
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5024744406713321676L</span><span class="p">;</span>  

    <span class="c1">// 底层使用HashMap来保存HashSet中所有元素。  </span>
    <span class="kd">private</span> <span class="kd">transient</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>  

    <span class="c1">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">PRESENT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>  

    <span class="cm">/** </span>
<span class="cm">     * 默认的无参构造器，构造一个空的HashSet。 </span>
<span class="cm">     *  </span>
<span class="cm">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="nf">HashSet</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>  
    <span class="p">}</span>  

    <span class="cm">/** </span>
<span class="cm">     * 构造一个包含指定collection中的元素的新set。 </span>
<span class="cm">     * </span>
<span class="cm">     * 实际底层使用默认的加载因子0.75和足以包含指定 </span>
<span class="cm">     * collection中所有元素的初始容量来创建一个HashMap。 </span>
<span class="cm">     * @param c 其中的元素将存放在此set中的collection。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="nf">HashSet</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">/</span><span class="mf">.75f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">));</span>  
    <span class="n">addAll</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>  
    <span class="p">}</span>  

    <span class="cm">/** </span>
<span class="cm">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span>
<span class="cm">     * </span>
<span class="cm">     * 实际底层以相应的参数构造一个空的HashMap。 </span>
<span class="cm">     * @param initialCapacity 初始容量。 </span>
<span class="cm">     * @param loadFactor 加载因子。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="nf">HashSet</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">loadFactor</span><span class="p">);</span>  
    <span class="p">}</span>  

    <span class="cm">/** </span>
<span class="cm">     * 以指定的initialCapacity构造一个空的HashSet。 </span>
<span class="cm">     * </span>
<span class="cm">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span>
<span class="cm">     * @param initialCapacity 初始容量。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="nf">HashSet</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">);</span>  
    <span class="p">}</span>  

    <span class="cm">/** </span>
<span class="cm">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span>
<span class="cm">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span>
<span class="cm">     * </span>
<span class="cm">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span>
<span class="cm">     * @param initialCapacity 初始容量。 </span>
<span class="cm">     * @param loadFactor 加载因子。 </span>
<span class="cm">     * @param dummy 标记。 </span>
<span class="cm">     */</span>  
    <span class="n">HashSet</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">dummy</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">loadFactor</span><span class="p">);</span>  
    <span class="p">}</span>  



    <span class="cm">/** </span>
<span class="cm">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">clone</span><span class="p">()</span> <span class="p">{</span>  
        <span class="k">try</span> <span class="p">{</span>  
            <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newSet</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">)</span> <span class="kd">super</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>  
            <span class="n">newSet</span><span class="p">.</span><span class="na">map</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">map</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>  
            <span class="k">return</span> <span class="n">newSet</span><span class="p">;</span>  
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">CloneNotSupportedException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="p">();</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>
</pre></div>
<h3>调用add方法/如何去重</h3>
<p>当你把对象加⼊ HashSet 时，HashSet会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会 与其他加⼊的对象的hashcode值作⽐᫾，如果没有相符的hashcode，HashSet会假设对象没有重复出 现。但是如果发现有相同hashcode值的对象，这时会调⽤ equals（） ⽅法来检查hashcode相等的对 象是否真的相同。如果两者相同，HashSet就不会让加⼊操作成功。（摘⾃我的Java启蒙书《Head fist java》第⼆版）</p>
<ul>
<li>如果此set中尚未包含指定元素，则添加指定元素。 </li>
<li>更确切地讲，如果此 set 没有包含满足(e\==null ? e2\==null : e.equals(e2)) 的元素e2，则向此set 添加指定的元素e。 </li>
<li>如果此set已包含该元素，则该调用不更改set并返回false。 </li>
<li>底层实际将将该元素作为key放入HashMap。 </li>
<li>由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）。新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </li>
<li>因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </li>
<li>原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/**  </span>
<span class="cm">     * @param e 将添加到此set中的元素。 </span>
<span class="cm">     * @return 如果此set尚未包含指定元素，则返回true。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">PRESENT</span><span class="p">)</span><span class="o">==</span><span class="kc">null</span><span class="p">;</span>  
    <span class="p">}</span>
</pre></div>
<h3>调用remove方法</h3>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 如果指定元素存在于此set中，则将其移除。 </span>
<span class="cm">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span>
<span class="cm">     * 则将其移除。如果此set已包含该元素，则返回true </span>
<span class="cm">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的remove方法删除指定Entry。 </span>
<span class="cm">     * @param o 如果存在于此set中则需要将其移除的对象。 </span>
<span class="cm">     * @return 如果set包含指定元素，则返回true。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">==</span><span class="n">PRESENT</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>调用clear方法</h3>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">map</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span>  
    <span class="p">}</span>
</pre></div>
<h3>迭代器遍历</h3>
<p>底层实际调用底层<strong>HashMap</strong>的<strong>keySet</strong>来返回所有的key。</p>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </span>
<span class="cm">     *  </span>
<span class="cm">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </span>
<span class="cm">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </span>
<span class="cm">     * value使用一个static final的Object对象标识。 </span>
<span class="cm">     * @return 对此set中元素进行迭代的Iterator。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">keySet</span><span class="p">().</span><span class="na">iterator</span><span class="p">();</span>  
    <span class="p">}</span>
</pre></div>
<p>也可以使用<code>for(Object obj : set)</code>的方式进行遍历</p>
<h3>size大小</h3>
<p>底层实际调用<strong>HashMap</strong>的<strong>size()</strong>方法返回Entry的数量，就得到该Set中元素的个数</p>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 返回此set中的元素的数量（set的容量）。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span>
<span class="cm">     * @return 此set中的元素的数量（set的容量）。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>  
    <span class="p">}</span>
</pre></div>
<h3>判断空</h3>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 如果此set不包含任何元素，则返回true。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span>
<span class="cm">     * @return 如果此set不包含任何元素，则返回true。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">();</span>  
    <span class="p">}</span>
</pre></div>
<h3>判断是否存在某个对象</h3>
<div class="highlight"><pre><span></span><span class="cm">/** </span>
<span class="cm">     * 如果此set包含指定元素，则返回true。 </span>
<span class="cm">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span>
<span class="cm">     * 的e元素时，返回true。 </span>
<span class="cm">     * </span>
<span class="cm">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span>
<span class="cm">     * @param o 在此set中的存在已得到测试的元素。 </span>
<span class="cm">     * @return 如果此set包含指定元素，则返回true。 </span>
<span class="cm">     */</span>  
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>  
    <span class="p">}</span>
</pre></div>
<h1>3. Map</h1>
<h2>3.1 HashMap</h2>
<p><figure><img data-width="706" data-height="436" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/017d96594affbad94816eac161973480.png" alt="" /></figure></p>
<h3>参考</h3>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/chentang/p/12670462.html">https://www.cnblogs.com/chentang/p/12670462.html</a></li>
<li><a href="https://www.cnblogs.com/wytiger/p/10731082.html">https://www.cnblogs.com/wytiger/p/10731082.html</a></li>
<li><a href="https://www.cnblogs.com/yuanblog/p/4441017.html">https://www.cnblogs.com/yuanblog/p/4441017.html</a></li>
<li><a href="https://blog.csdn.net/v123411739/article/details/78996181?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">最全源码解析</a></li>
</ul>
</blockquote>
<h3>哈希表&amp;哈希冲突</h3>
<p>​   在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<blockquote><p><strong>存储位置 = f(关键字)</strong></p>
</blockquote>
<p>其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>
<p><figure><img data-width="759" data-height="511" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/5fda0baf271aaccfe5287b92cab676f9.jpg" alt="" /></figure></p>
<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？</p>
<ul>
<li><strong>链地址法：</strong>将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li>
</ul>
<h3>HashMap数据结构</h3>
<p><strong>HashMap</strong>的主干是一个变量名为<strong>table</strong>的<strong>Entry/Node数组</strong>。<strong>Entry/Node</strong>是<strong>HashMap</strong>的基本组成单元，每一个<strong>Entry/Node</strong>包含一个<strong>key-value</strong>键值对。</p>
<div class="highlight"><pre><span></span><span class="c1">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂</span>
<span class="kd">transient</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="p">)</span> <span class="n">EMPTY_TABLE</span><span class="p">;</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
        <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="p">;</span>
        <span class="n">V</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>

        <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>
<ul>
<li><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</strong></li>
<li><strong>如果定位到的数组位置不含链表（当前entry的next指向null）：那么对于查找，添加等操作很快，仅需一次寻址即可；</strong></li>
<li><strong>如果定位到的数组包含链表：对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。</strong></li>
</ul>
<p><figure><img data-width="793" data-height="640" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/56fe0a3cc118a5a0ad333947a6cd1e00.png" alt="" /></figure></p>
<p><figure><img data-width="829" data-height="418" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/da0c607659efa08f2778f5c7ca2997f4.png" alt="" /></figure></p>
<h3>HashMap属性</h3>
<ul>
<li><strong>initialCapacity：</strong>初始容量。指的是 HashMap 集合初始化的时候自身的容量。可以在构造方法中指定；如果不指定的话，总容量默认值是 <strong>16</strong> 。需要注意的是初始容量必须是 2 的幂次方。</li>
<li><strong>size：</strong>当前 HashMap 中已经存储着的键值对数量，即 HashMap.size()</li>
<li><strong>loadFactor：</strong>加载因子。所谓的加载因子就是 HashMap (当前的容量/总容量) 到达一定值的时候，HashMap 会实施扩容。加载因子也可以通过构造方法中指定，默认的值是 0.75 。举个例子，假设有一个 HashMap 的初始容量为 16 ，那么扩容的阀值就是 0.75 * 16 = 12 。也就是说，在你打算存入第 13 个值的时候，HashMap 会先执行扩容。</li>
<li><strong>threshold：</strong>扩容阀值。即 扩容阀值 = HashMap 总容量 * 加载因子。当前 HashMap 的容量大于或等于扩容阀值的时候就会去执行扩容。扩容的容量为当前 HashMap 总容量的两倍。比如，当前 HashMap 的总容量为 16 ，那么扩容之后为 32 。</li>
<li><strong>table：</strong>1.8之前为Entry 数组，1.8之后为Node数组。我们都知道 HashMap 内部存储 key/value 是通过 Entry/Node 这个介质来实现的。</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">implements</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Cloneable</span><span class="p">,</span> <span class="n">Serializable</span> <span class="p">{</span>
    <span class="c1">//序列号，序列化的时候使用。</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">362498820763181265L</span><span class="p">;</span>
    <span class="cm">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
    <span class="c1">//最大容量，2的30次方。</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
    <span class="c1">//加载因子，用于扩容使用。</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="p">;</span>
    <span class="c1">//当某个桶节点数量大于8时，会转换为红黑树。</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">//当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="c1">//当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="c1">//存储元素的数组，transient关键字表示该属性不能被序列化</span>
    <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="p">;</span>
    <span class="c1">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span>
    <span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="p">;</span>
    <span class="c1">//元素数量</span>
    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="c1">//统计该map修改的次数</span>
    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="p">;</span>
    <span class="c1">//临界值，也就是元素数量达到临界值时，会进行扩容。</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="c1">//也是加载因子，只不过这个是变量。</span>
    <span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="p">;</span>
</pre></div>
<h3>HashMap常用内部类</h3>
<p><strong>红黑树结构</strong></p>
<div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>  
        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="p">;</span>    
        <span class="kt">boolean</span> <span class="n">red</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">super</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><strong>结点类</strong></p>
<div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
        <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="p">;</span>
        <span class="n">V</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>

        <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>构造方法</h3>
<ul>
<li>无参构造方法，默认容量<strong>16</strong>，默认的加载因子<strong>0.75</strong></li>
<li>设置初始容量，并使用默认的加载因子<strong>0.75</strong>，调用的方法是第三个构造方法，将默认<strong>DEFAULT_LOAD_FACTOR</strong>作为形参传入第三个构造函数</li>
<li>设置初始容量和加载因子</li>
<li>传入一个Map，然后把该Map转为hashMap</li>
</ul>
<p><strong>无参构造方法</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">HashMap</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">;</span> 
    <span class="p">}</span>
</pre></div>
<p><strong>设置初始容量，并使用默认的加载因子0.75</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">HashMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<p><strong>设置初始容量和加载因子</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">HashMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="p">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Illegal initial capacity: &quot;</span> <span class="o">+</span>
                                               <span class="n">initialCapacity</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span>
            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">Float</span><span class="p">.</span><span class="na">isNaN</span><span class="p">(</span><span class="n">loadFactor</span><span class="p">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Illegal load factor: &quot;</span> <span class="o">+</span>
                                               <span class="n">loadFactor</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<p><strong>传入一个Map，然后把该Map转为hashMap</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">HashMap</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="p">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">;</span>
        <span class="n">putMapEntries</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putMapEntries</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="p">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//获取该map的实际长度</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//判断table是否初始化，如果没有初始化</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// pre-size</span>
                <span class="cm">/**求出需要的容量，因为实际使用的长度=容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数的，后面转换为int，多余的小数就要被丢掉，所以+1，例如，map实际长度22，22/0.75=29.3,所需要的容量肯定为30，有人会问如果刚刚好除得整数呢，除得整数的话，容量大小多1也没什么影响**/</span>
                <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">s</span> <span class="o">/</span> <span class="n">loadFactor</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0F</span><span class="p">;</span>
                <span class="c1">//判断该容量大小是否超出上限。</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="n">ft</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="o">?</span>
                         <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ft</span> <span class="p">:</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">);</span>
                <span class="cm">/**对临界值进行初始化，tableSizeFor(t)这个方法会返回大于t值的，且离其最近的2次幂，例如t为29，则返回的值是32**/</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
                    <span class="n">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">//如果table已经初始化，则进行扩容操作，resize()就是扩容。</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
                <span class="n">resize</span><span class="p">();</span>
            <span class="c1">//遍历，把map中的数据转到hashMap中。</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="p">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">getKey</span><span class="p">();</span>
                <span class="n">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
                <span class="n">putVal</span><span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="n">evict</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<h3>put()：添加一个键值对/扩容机制</h3>
<p>向map中添加值(返回这个key以前的值,如果没有返回null)</p>
<p><figure><img data-width="1716" data-height="1360" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/a9b583621c8de6a6fe8a510c40bbf81f.png" alt="" /></figure></p>
<p><strong>计算hash值</strong></p>
<p>先获取到key的hashCode，然后进行移位再进行异或运算算出要插入的索引，为什么这么复杂，不用想肯定是为了减少hash冲突。如果key为空就返回索引0，也就是说插入到第一个结点。</p>
<div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="n">Object</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">())</span> <span class="o">^</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<p><strong>方法源码</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="p">(</span><span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/</span>
        <span class="k">return</span> <span class="n">putVal</span><span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="p">,</span>
                   <span class="kt">boolean</span> <span class="n">evict</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//tab 哈希数组，p 该哈希桶的首节点，n hashMap的长度，i 计算出的数组下标</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="p">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="c1">//获取长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="p">()).</span><span class="na">length</span><span class="p">;</span>
        <span class="cm">/**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">]</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
        <span class="c1">//发生哈希冲突的几种情况</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// e 临时节点的作用， k 存放该当前节点的key </span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">;</span> <span class="n">K</span> <span class="n">k</span><span class="p">;</span>
            <span class="c1">//第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="c1">//第二种，hash值不等于首节点，判断该p是否属于红黑树的节点</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="p">)</span>
                <span class="cm">/**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/</span>
                <span class="n">e</span> <span class="o">=</span> <span class="p">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">p</span><span class="p">).</span><span class="na">putTreeVal</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="c1">//第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">//遍历该链表</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="o">++</span><span class="n">binCount</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">p</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
                        <span class="c1">//判断是否要转换为红黑树结构</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 
                            <span class="n">treeifyBin</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">//如果链表中有重复的key，e则为当前重复的节点，结束循环</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                        <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">//有重复的key，则用待插入值进行覆盖，返回旧值。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> 
                <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                    <span class="n">e</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                <span class="n">afterNodeAccess</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null</span>
        <span class="c1">//修改次数+1</span>
        <span class="o">++</span><span class="n">modCount</span><span class="p">;</span>
        <span class="c1">//实际长度+1，判断是否大于临界值，大于则扩容</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="n">resize</span><span class="p">();</span>
        <span class="n">afterNodeInsertion</span><span class="p">(</span><span class="n">evict</span><span class="p">);</span>
        <span class="c1">//添加成功</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<p><strong>resize()扩容操作</strong></p>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/weixin_43689776/article/details/95335330?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159897939119724836748682%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159897939119724836748682&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-95335330.pc_v2_rank_blog_default&amp;utm_term=%E6%89%A9%E5%AE%B9&amp;spm=1018.2118.3001.4187">HashMap的底层实现原理和为何扩容为2的次数幂及与HashTable的区别。</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制</a></li>
</ul>
</blockquote>
<p>​   当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>​    那么hashmap什么时候进行扩容呢？<strong>当hashmap中的元素个数超过阈值大小threshold</strong>时，就会进行数组扩容<strong>，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过</strong>16 × 0.75 = 12<strong>的时候，就把数组的大小扩展为</strong>2 × 16=32<strong>，</strong>即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作<strong>，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0</strong>.75 × 1000 &lt; 1000<strong>, 也就是说为了让</strong>0.75 × size &gt; 1000**, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>
<div class="highlight"><pre><span></span><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//把没插入之前的哈希数组做我诶oldTal</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
        <span class="c1">//old的长度</span>
        <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">oldTab</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
        <span class="c1">//old的临界值</span>
        <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>
        <span class="c1">//初始化new的长度和临界值</span>
        <span class="kt">int</span> <span class="n">newCap</span><span class="p">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">//oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//大于最大值</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//临界值为整数的最大值</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">oldTab</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//标记##，其它情况，扩容两倍，并且扩容后的长度要小于最大值，old长度也要大于16</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                     <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">)</span>
                <span class="c1">//临界值也扩容为old的临界值2倍</span>
                <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="cm">/**如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，        </span>
<span class="cm">           如果是首次初始化，它的临界值则为0</span>
<span class="cm">        **/</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="p">;</span>
        <span class="c1">//首次初始化，给与默认的值</span>
        <span class="k">else</span> <span class="p">{</span>               
            <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">;</span>
            <span class="c1">//临界值等于容量*加载因子</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//此处的if为上面标记##的补充，也就是初始化时容量小于默认值16的，此时newThr没有赋值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//new的临界值</span>
            <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="p">;</span>
            <span class="c1">//判断是否new容量是否大于最大值，临界值是否大于最大值</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="p">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                      <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ft</span> <span class="p">:</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="p">;</span>
        <span class="c1">//表示忽略该警告</span>
        <span class="nd">@SuppressWarnings</span><span class="p">({</span><span class="s">&quot;rawtypes&quot;</span><span class="p">,</span><span class="s">&quot;unchecked&quot;</span><span class="p">})</span>
            <span class="c1">//初始化</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="p">)</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">]</span><span class="p">;</span>
        <span class="c1">//赋予当前的table</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="p">;</span>
        <span class="c1">//此处自然是把old中的元素，遍历到new中</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//临时变量</span>
                <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">;</span>
                <span class="c1">//当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//把已经赋值之后的变量置位null，当然是为了好回收，释放内存</span>
                    <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                    <span class="c1">//如果下标处的节点没有下一个元素</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                        <span class="c1">//把该变量的值存入newCap中，e.hash &amp; (newCap - 1)并不等于j</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                    <span class="c1">//该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="p">)</span>
                        <span class="c1">//把此树进行转移到newCap中</span>
                        <span class="p">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">e</span><span class="p">).</span><span class="na">split</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">newTab</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">oldCap</span><span class="p">);</span>
                    <span class="k">else</span> <span class="p">{</span> <span class="cm">/**此处表示为链表结构，同样把链表转移到newCap中，就是把链表遍历后，把值转过去，在置位null**/</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
                        <span class="k">do</span> <span class="p">{</span>
                            <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
                            <span class="k">if</span> <span class="p">((</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                                    <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                                <span class="k">else</span>
                                    <span class="n">loTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                                <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                                    <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                                <span class="k">else</span>
                                    <span class="n">hiTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                                <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">loTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">hiTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//返回扩容后的hashMap</span>
        <span class="k">return</span> <span class="n">newTab</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<h3>HashMap 的⻓度为什么是2的幂次⽅</h3>
<p>为了能让 HashMap 存取⾼效，尽量减少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过 了，Hash 值的范围值-2147483648到2147483647，前后加起来⼤概40亿的映射空间，只要哈希函数映射 得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。但问题是⼀个40亿⻓度的数组，内存是放不下的。所以 这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放 的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ <code>(n - 1) &amp; hash</code> ”。（n代表数组⻓ 度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p>
<p>这个算法应该如何设计呢？</p>
<p>我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则 等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%lengthdehash&amp;(length-1)的前提是 length 是2的 n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率，这就解释了 HashMap 的⻓度 为什么是2的幂次⽅。</p>
<h3>JDK1.8中HashMap如何应对hash冲突？</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/weixin_43689776/article/details/99999126?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">JDK1.8中HashMap如何应对hash冲突</a></li>
</ul>
</blockquote>
<h3>为什么HashMap线程不安全</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/swpu_ocean/article/details/88917958">https://blog.csdn.net/swpu_ocean/article/details/88917958</a></li>
</ul>
</blockquote>
<p><strong>总结</strong></p>
<blockquote><ul>
<li><strong>在JDK1.7中</strong>：当并发执行扩容操作时会造成环形链和数据丢失的情况。</li>
<li><strong>在JDK1.8中</strong>：在并发执行put操作时会发生数据覆盖的情况。</li>
</ul>
</blockquote>
<h3>为什么用红黑树不用AVL树</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/21aspnet/article/details/88939297">https://blog.csdn.net/21aspnet/article/details/88939297</a></li>
</ul>
</blockquote>
<p>AVL</p>
<blockquote><p>完全平衡二叉树</p>
</blockquote>
<p>最主要的一点是：</p>
<p>在<code>CurrentHashMap</code>中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！</p>
<p>红黑树和AVL树都是<strong>最常用的平衡二叉搜索树</strong>，它们的查找、删除、修改都是O(lgn) time</p>
<p>AVL树和红黑树有几点比较和区别：</p>
<blockquote><ul>
<li>AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。</li>
<li>红黑树更适合于插入修改密集型任务。</li>
<li>通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ul>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote><ul>
<li>AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</li>
<li>两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li>
<li>在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。</li>
<li>两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。</li>
</ul>
</blockquote>
<h2>3.2 LinkedHashMap</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.imooc.com/article/22931">https://www.imooc.com/article/22931</a></li>
</ul>
</blockquote>
<h2>3.3 ConcurrentHashMap</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/chengxiao/p/6842045.html">https://www.cnblogs.com/chengxiao/p/6842045.html</a></li>
<li><a href="https://www.jianshu.com/p/d0b37b927c48">https://www.jianshu.com/p/d0b37b927c48</a></li>
</ul>
</blockquote>
<p>ConcurrentHashMap是Java并发包<code>java.util.concurrent</code>中提供的一个线程安全且高效的HashMap实现，ConcurrentHashMap在并发编程的场景中使用频率非常之高，本文就来分析下<code>ConcurrentHashMap</code>的实现原理，并对其实现原理进行分析（JDK1.7).</p>
<p>众所周知，哈希表是中非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理。</p>
<blockquote><ul>
<li><strong>HashMap</strong> ：先说HashMap，HashMap是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</li>
<li><strong>HashTable</strong> ： HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。</strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在竞争激烈的并发场景中性能就会非常差。</li>
</ul>
</blockquote>
<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的"<strong>分段锁</strong>"思想。</p>
<p><figure><img data-width="1798" data-height="944" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/e028b0f23f1ddf9325be8111fcfc1ef1.png" alt="" /></figure></p>
<p>如何实现线程安全</p>
<p><figure><img data-width="801" data-height="655" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/ce5731b9fb14b23486b6ce342ceb5948.png" alt="" /></figure></p>
<h2>区别</h2>
<h3>HashMap与Hashtable区别</h3>
<blockquote><ol>
<li><strong>线程是否安全</strong>： HashMap 是⾮线程安全的，HashTable 是线程安全的；HashTable 内部的⽅法 基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap 吧！）； </li>
<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，HashTable 基本被 淘汰，不要在代码中使⽤它； </li>
<li><strong>对Null key 和Null value的⽀持</strong>： HashMap 中，null 可以作为键，这样的键只有⼀个，可以 有⼀个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有⼀个 null， 直接抛出 NullPointerException。 </li>
<li><strong>初始容量⼤⼩和每次扩充容量⼤⼩的不同</strong> ： ①创建时如果不指定容量初始值，Hashtable 默认 的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后 每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤ 你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 tableSizeFor() ⽅ 法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介 绍到为什么是2的幂次⽅。 </li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了巨⼤的变化，当链表⻓度⼤于 阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
</blockquote>
<h3>ConcurrentHashMap 和 Hashtable 的区别</h3>
<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。</p>
<blockquote><ul>
<li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤ 的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是 主要为了解决哈希冲突⽽存在的； </li>
<li>实现线程安全的⽅式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶 数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数 据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的 概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线 程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只 是为了兼容旧版本；② Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常 低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如 使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈 效率越低。</li>
</ul>
</blockquote>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/Java-JVM/">
                    <time>August 23 2020</time>
                    <span>Java-JVM</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/Java-多线程并发/">
                    <time>August 23 2020</time>
                    <span>Java-多线程并发</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u7565\u61c2"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 ze</span>
                        
    <span class="leancloud_visitors"
            id="/archives/Java-集合容器/" 
            data-flag-title="Java-集合容器">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>