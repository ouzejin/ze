<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,ZE,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="ze &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="ze &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/591f9f7764a8fd2466b8ba7b37e37a9e.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>Java-基础面试题 - ze</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="Java基础面试题" />
<meta property="og:title" content="Java-基础面试题 - ze" />
<meta property="og:description" content="Java基础面试题" />
<meta property="og:site_name" content="ze" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/Java-基础面试题/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-08-08T23:24:32-00.00" />
<meta name="twitter:title" content="Java-基础面试题 - ze" />
<meta name="twitter:description" content="Java基础面试题" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/avatar.png">ze</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.ze.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.ze.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/ouzejin" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/ouzejin" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class=" "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/Redis/">Redis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Redis实现高并发秒杀系统/">Redis实现高并发秒杀系统</a></li><li class=""><a href="/archives/Redis部署与基本使用/">Redis部署与基本使用</a></li><li class=""><a href="/archives/Redis实现单点登录/">Redis实现单点登录</a></li><li class=""><a href="/archives/Redis理论学习笔记/">Redis理论学习笔记</a></li></ul></div><li class=""><a href="/archives/SQL学习笔记/">SQL学习笔记</a></li><li class=""><a href="/archives/Mysql理论学习笔记/">Mysql理论学习笔记</a></li><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class="open "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-时间处理/">Java-时间处理</a></li><li class=""><a href="/archives/Java-反射/">Java-反射</a></li><li class=""><a href="/archives/Java-JDK8新特性/">Java-JDK8新特性</a></li><li class=""><a href="/archives/Java-IO/">Java-IO</a></li><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class=""><a href="/archives/Java-集合容器/">Java-集合容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class="current"><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/腾讯云学习笔记/">腾讯云学习笔记</a></li><li class=""><a href="/archives/面试题整理/">面试题整理</a></li><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class=" "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Swagger使用/">Swagger使用</a></li><li class=""><a href="/archives/Lombok使用/">Lombok使用</a></li><li class=""><a href="/archives/Maven中依赖的scope总结/">Maven中依赖的scope总结</a></li><li class=""><a href="/archives/Devtools对Springboot热部署/">Devtools对Springboot热部署</a></li><li class=""><a href="/archives/IDEA配置Run Dashboard/">IDEA配置Run Dashboard</a></li><li class=""><a href="/archives/IDEA初始化SpringBoot项目+逆向工程+配置/">IDEA初始化SpringBoot项目+逆向工程+配置</a></li><li class=""><a href="/archives/EasyExcel导入导出Excel/">EasyExcel导入导出Excel</a></li><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/Mybatis/">Mybatis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Mybatis学习笔记/">Mybatis学习笔记</a></li><li class=""><a href="/archives/Mybatis逆向工程&Example类使用/">Mybatis逆向工程&Example类使用</a></li></ul></div><li class=""><a href="/archives/HttpServletrequest与HttpServletResponse/">HttpServletrequest与HttpServletResponse</a></li><li class=""><a href="/archives/SpringMVC基础&面试/">SpringMVC基础&面试</a></li><li class=""><a href="/archives/SpringMVC注解/">SpringMVC注解</a></li><li class=""><a href="/archives/Spring基础&面试/">Spring基础&面试</a></li><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/前端/">前端</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/JavaScript面试题/">JavaScript面试题</a></li><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法基础笔记/">数据结构&算法基础笔记</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.ze.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.ze.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/ouzejin">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/ouzejin">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">Java-基础面试题</h1>
        <p class="post-meta">
            <time>August 08 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/面试/">#面试</a>
                </span>
                
                <span>
                    <a href="/tag/Java/">#Java</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h1>学习路线</h1>
<p><figure><img data-width="628" data-height="808" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/f53560858e548e5859e3b095609cd821.png" alt="" /></figure></p>
<h1>JDK和JRE区别</h1>
<ul>
<li><strong><u>JDK（Java Development Kit）</u></strong>是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。</li>
<li><strong><u>Java Runtime Environment（JRE）</u></strong>是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</li>
<li><strong><u>Java Virtual Machine（Java虚拟机JVM）</u></strong>的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</li>
</ul>
<p><figure><img data-width="904" data-height="493" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/4be18fd971a5c330e26e143bddbe8542.png" alt="" /></figure></p>
<h2>JDK（Java Development Kit）</h2>
<ul>
<li>JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</li>
<li>JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li>SE(J2SE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。</li>
<li>EE(J2EE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。</li>
<li>ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</li>
</ul>
<h2>JRE（Java Runtime Environment）</h2>
<p>​       是运行基于Java语言编写的程序所不可缺少的运行环境。RE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。<strong>但是在运行编译好的程序中包含Servlet时，需要JDK</strong></p>
<h2>JVM（Java Virtual Machine）</h2>
<p>​       就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p>
<p>也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p>
<p>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h1>重载和重写</h1>
<h2>重载(Overload)</h2>
<ol>
<li>重载Overload是一个类中多态性的一种表现或者一个类中多个构造器的实现</li>
<li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li>
<li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Father</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Father</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">(</span><span class="s">&quot;wintershii&quot;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>重写(Override)</h2>
<ol>
<li><strong>发生在父类与子类之间</strong></li>
<li><strong>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</strong></li>
<li>访问修饰符的限制一定要<strong>大于</strong>被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Son</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span><span class="p">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;hello by &quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
<h2>重载（Overload）和重写（Override）的区别</h2>
<p>​       方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>
<h2>构造器Constructor是否可被Override(重写)</h2>
<p>​       构造器Constructor不能被继承，因此不能被<strong>重写(Override)</strong>，但是可以被<strong>重载（Overload）</strong>。如果父类自定义了有参构造函数，则子类无论定义构造函数与否，定义有参构造函数与否，都会报错，正确的做法是在子类的构造方法中添上super（参数），以表明子类构造之前先构造父类，而这句话必须放在第一句，否则报"Constructor call must be the first statement in a constructor"的错误。</p>
<h1>类的加载顺序</h1>
<ol>
<li>父类的静态代码块/初始化静态变量（两者优先级相同）</li>
<li>执行子类的静态代码/初始化静态变量（两者优先级相同，谁写在前面谁先执行）</li>
<li>初始化父类成员变量/执行代码块{}（两者优先级相同），父类的构造器</li>
<li>子类的成员变量/代码块，最后子类的构造器。</li>
</ol>
<p>例如：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">);</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;test static&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">Test</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;test constructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">new</span> <span class="n">MyClass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;person static&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;person &quot;</span><span class="o">+</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="nc">MyClass</span> <span class="kd">extends</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;MyClass&quot;</span><span class="p">);</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;myclass static&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;myclass constructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>结果：</p>
<blockquote><ul>
<li>test static</li>
<li>myclass static</li>
<li>person static</li>
<li>person Test</li>
<li>test constructor</li>
<li>person MyClass</li>
<li>myclass constructor</li>
</ul>
</blockquote>
<p>顺序解析：</p>
<blockquote><ul>
<li>首先加载Test类，因此会执行Test类中的static块。</li>
<li>接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。</li>
<li>在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，</li>
<li>接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</li>
</ul>
</blockquote>
<h1>三大特性封装继承多态</h1>
<p><figure><img data-width="672" data-height="519" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/580e90e67848582220c27c9295576f74.png" alt="" /></figure></p>
<h2>封装</h2>
<p>​       封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。实体类那些属性就是被封装</p>
<ul>
<li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li>
<li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li>
<li>隐藏对象的信息。</li>
<li>留出访问的对外接口。</li>
</ul>
<h2>继承</h2>
<p>​       继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(<code>private</code>修饰)，<strong>则子类是不能被继承的。</strong></p>
<p>只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。</p>
<ul>
<li>子类可以拥有父类的属性和方法。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以重写覆盖父类的方法。</li>
</ul>
<h3>使用</h3>
<p>在父子类关系继承中，<strong>如果成员变量重名</strong>，则创建子类对象时，访问有两种方式。</p>
<ul>
<li><p>直接通过子类对象访问成员变量</p>
<p>等号左边是谁，就优先使用谁，如果没有就向上找。</p>
</li>
<li><p>间接通过成员方法访问成员变量</p>
<p>该方法属于谁，谁就优先使用，如果没有就向上找。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FU</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">numFU</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类成员变量：&quot;</span><span class="o">+</span><span class="n">numFU</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodFU</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类成员方法!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="n">FU</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">numZi</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类成员变量：&quot;</span><span class="o">+</span><span class="n">numFU</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodZi</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;子类方法！&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExtendDemo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">FU</span> <span class="n">fu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FU</span><span class="p">();</span>
        <span class="c1">// 父类的实体对象只能调用父类的成员变量</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类：&quot;</span> <span class="o">+</span> <span class="n">fu</span><span class="p">.</span><span class="na">numFU</span><span class="p">);</span>   <span class="c1">// 结果：10</span>

        <span class="n">Zi</span> <span class="n">zi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Zi</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用父类：&quot;</span> <span class="o">+</span> <span class="n">zi</span><span class="p">.</span><span class="na">numFU</span><span class="p">);</span> <span class="c1">// 结果：10</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;子类：&quot;</span> <span class="o">+</span> <span class="n">zi</span><span class="p">.</span><span class="na">numZi</span><span class="p">);</span>   <span class="c1">// 结果：20</span>

        <span class="cm">/** 输出结果为200，证明在重名情况下，如果子类中存在则优先使用，</span>
<span class="cm">         *  如果不存在则去父类查找，但如果父类也没有那么编译期就会报错。</span>
<span class="cm">         */</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">zi</span><span class="p">.</span><span class="na">num</span><span class="p">);</span> <span class="c1">// 结果：200</span>
        <span class="cm">/**</span>
<span class="cm">         * 通过成员方法调用成员变量</span>
<span class="cm">         */</span>
        <span class="n">zi</span><span class="p">.</span><span class="na">method</span><span class="p">();</span>    <span class="c1">// 结果：10</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>多态</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/qq_31655965/article/details/54746235">https://blog.csdn.net/qq_31655965/article/details/54746235</a></li>
</ul>
</blockquote>
<p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>实现方式</strong></p>
<ul>
<li>接口多态性。</li>
<li>继承多态性。</li>
<li>通过抽象类实现的多态性。</li>
</ul>
<h3>举例</h3>
<p>多态，简而言之就是同一个行为具有多个不同表现形式或形态的能力。比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了。我摸水杯这个动作，对于不同温度的水，就会得到不同的结果。这就是多态。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Water</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showTem</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的温度是: 0度&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IceWater</span> <span class="kd">extends</span> <span class="n">Water</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showTem</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的温度是: 0度&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WarmWater</span> <span class="kd">extends</span> <span class="n">Water</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showTem</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的温度是: 40度&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HotWater</span> <span class="kd">extends</span> <span class="n">Water</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showTem</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的温度是: 100度&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestWater</span><span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Water</span> <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WarmWater</span><span class="p">();</span>
        <span class="n">w</span><span class="p">.</span><span class="na">showTem</span><span class="p">();</span>

        <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IceWater</span><span class="p">();</span>
        <span class="n">w</span><span class="p">.</span><span class="na">showTem</span><span class="p">();</span>

        <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HotWater</span><span class="p">();</span>
        <span class="n">w</span><span class="p">.</span><span class="na">showTem</span><span class="p">();</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//结果:</span>
<span class="c1">//我的温度是: 40度</span>
<span class="c1">//我的温度是: 0度</span>
<span class="c1">//我的温度是: 100度</span>
</pre></div>
<p>这里的方法<code>showTem()</code>就相当于你去摸水杯。我们定义的water类型的引用变量w就相当于水杯，你在水杯里放了什么温度的水，那么我摸出来的感觉就是什么。就像代码中的那样，放置不同温度的水，得到的温度也就不同，但水杯是同一个。</p>
<h3>分类</h3>
<ul>
<li><strong>重写式多态</strong>：也叫编译时多态。也就是说这种多态再编译时已经确定好了。重载大家都知道，方法名相同而参数列表不同的一组方法就是重载。在调用这种重载的方法时，通过传入不同的参数最后得到不同的结果。</li>
</ul>
<ul>
<li><strong>重载式多态</strong>：也叫运行时多态。这种多态通过动态绑定（dynamic binding）技术来实现，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。
这种多态通过<code>函数的重写</code>以及<code>向上转型</code>来实现，我们上面代码中的例子就是一个完整的重写式多态。我们接下来讲的所有多态都是重写式多态，因为它才是面向对象编程中真正的多态。</li>
</ul>
<h3>条件</h3>
<ul>
<li><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</li>
<li><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
<h3>向上转型</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/qq_31655965/article/details/54746235">https://blog.csdn.net/qq_31655965/article/details/54746235</a></li>
</ul>
</blockquote>
<p><figure><img data-width="1372" data-height="592" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/ae6316ac34c01a4db403e8e329d0425b.png" alt="" /></figure></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;animal eatting...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我吃鱼&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我吃骨头&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我会跑&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">();</span> <span class="c1">//向上转型</span>
        <span class="n">animal</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>

        <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="p">();</span>
        <span class="n">animal</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//结果:</span>
<span class="c1">//我吃鱼</span>
<span class="c1">//我吃骨头</span>
</pre></div>
<p><strong>注意事项</strong></p>
<ul>
<li>向上转型时，子类单独定义的方法会丢失。比如上面<code>Dog</code>类中定义的<code>run</code>方法，当<code>animal</code>引用指向<code>Dog</code>类实例时是访问不到<code>run</code>方法的，<code>animal.run()</code>会报错。</li>
<li>子类引用不能指向父类对象。<code>Cat c = (Cat)new Animal()</code>这样是不行的。</li>
</ul>
<p><strong>好处</strong></p>
<ul>
<li>减少重复代码，使代码变得简洁。</li>
<li>提高系统扩展性。</li>
</ul>
<p>坏处</p>
<ul>
<li>无法使用子类特定的方法</li>
</ul>
<p>使用场景</p>
<ul>
<li>不需要面对子类型，通过提高扩展性，或者使用父类的功能即可完成操作，就是使用向上转型。</li>
</ul>
<p>比如我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要像下面这样写</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(</span><span class="n">Cat</span> <span class="n">c</span><span class="p">){</span>
    <span class="n">c</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(</span><span class="n">Dog</span> <span class="n">d</span><span class="p">){</span>
    <span class="n">d</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//......</span>

<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Dog</span><span class="p">());</span>
<span class="c1">//......</span>
</pre></div>
<blockquote><p>此时每增加一种动物就要多写一个方法来接收不同的参数</p>
</blockquote>
<p>如果使用向上转型</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(</span><span class="n">Animal</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">a</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Dog</span><span class="p">());</span>
<span class="c1">//.....</span>
</pre></div>
<blockquote><p>因为其他动物类是Animal的子类，可以接收，就像<code>double</code>类型可以接收<code>int</code>，但<code>int</code>类型接收<code>double</code>就会精度缺失。而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法</p>
</blockquote>
<p><strong>经典案例</strong></p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">show</span><span class="p">(</span><span class="n">D</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;A and D&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">show</span><span class="p">(</span><span class="n">A</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;A and A&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span><span class="p">{</span>
  <span class="c1">//父类没有此方法，虽然方法名字一样，但是由于参数不同不是重写</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">show</span><span class="p">(</span><span class="n">B</span> <span class="n">obj</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;B and B&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">show</span><span class="p">(</span><span class="n">A</span> <span class="n">obj</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;B and A&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="n">B</span><span class="p">{</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">D</span> <span class="kd">extends</span> <span class="n">B</span><span class="p">{</span>

<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
        <span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">();</span>
        <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">();</span>
        <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
        <span class="n">D</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">();</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;1--&quot;</span> <span class="o">+</span> <span class="n">a1</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;2--&quot;</span> <span class="o">+</span> <span class="n">a1</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;3--&quot;</span> <span class="o">+</span> <span class="n">a1</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;4--&quot;</span> <span class="o">+</span> <span class="n">a2</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;5--&quot;</span> <span class="o">+</span> <span class="n">a2</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;6--&quot;</span> <span class="o">+</span> <span class="n">a2</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;7--&quot;</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;8--&quot;</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;9--&quot;</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="na">show</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//结果：</span>
<span class="c1">//1--A and A</span>
<span class="c1">//2--A and A</span>
<span class="c1">//3--A and D</span>
<span class="c1">//4--B and A</span>
<span class="c1">//5--B and A</span>
<span class="c1">//6--A and D</span>
<span class="c1">//7--B and B</span>
<span class="c1">//8--B and B</span>
<span class="c1">//9--A and D</span>
</pre></div>
<p>当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。<strong>如果子类中没有覆盖该方法，那么会去父类中寻找</strong>。</p>
<blockquote><p>继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p>
<p>事实上，子类继承了父类的方法，所以所谓super.show(O)时调用的是在子类中继承下来的方法</p>
</blockquote>
<p>解析第四个</p>
<blockquote><p>a2为指向B对象的A类的引用类型，当调用<code>show(B obj)</code>时，会首先去父类找是否有此方法，如果没有那么即使子类有此方法但不会去调用(超出范围)，因为引用类型决定了能调用的方法(即使不是调用自己类的方法)，所以B类中的<code>show(B obj)</code>没有被调用(如果有就会调用子类的<code>show(B obj)</code>)。这时候按照顺序会调用<code>this.show((super)O)</code>,参数为能向上转型的类型，可以发现A类中有<code>show(A obj)</code>，那么就去子类中看是否有此方法，发现有那么调用子类的<code>show(A obj)</code>（如果没有就直接调用父类A类的此方法）。所以最后<code>a2.show(b)</code>调用的是子类B类方法<code>show(A obj)</code>，结果返回<code>"B and A"</code></p>
</blockquote>
<p>解析第九个</p>
<blockquote><p>虽然b的引用类型和指向对象都是B，但是在调用<code>b.show(d)</code>是我们以为会调用B类中的<code>show(B obj)</code>方法，但由于B继承下来A类中<code>show(D obj)</code>方法，相当于B类中有此方法，所以会调用B类中<code>show(D obj)</code>。所以结果为<code>"A and D"</code></p>
</blockquote>
<h3>向下转型</h3>
<p><figure><img data-width="1372" data-height="592" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/ae6316ac34c01a4db403e8e329d0425b.png" alt="" /></figure></p>
<p>好处</p>
<ul>
<li>不仅能继承父类的方法，还可以使用子类型的特有功能</li>
</ul>
<p>坏处</p>
<ul>
<li>面对具体的子类型，向下转型具有风险。即容易发生<code>ClassCastException</code>，只要转换类型和对象不匹配就会发生。解决方法：使用关键字<code>instanceof</code>。</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">//还是上面的animal和cat dog</span>
<span class="n">Animal</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">();</span>
<span class="n">Cat</span> <span class="n">c</span> <span class="o">=</span> <span class="p">((</span><span class="n">Cat</span><span class="p">)</span> <span class="n">a</span><span class="p">);</span>
<span class="n">c</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="c1">//输出  我吃鱼</span>
<span class="n">Dog</span> <span class="n">d</span> <span class="o">=</span> <span class="p">((</span><span class="n">Dog</span><span class="p">)</span> <span class="n">a</span><span class="p">);</span>
<span class="n">d</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="c1">// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Cat cannot be cast to com.chengfan.animal.Dog</span>
<span class="n">Animal</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="p">();</span>
<span class="n">Cat</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">((</span><span class="n">Cat</span><span class="p">)</span> <span class="n">a1</span><span class="p">);</span>
<span class="n">c1</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
<span class="c1">// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Animal cannot be cast to com.chengfan.animal.Cat</span>
</pre></div>
<blockquote><ul>
<li>向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）</li>
<li>向下转型只能转型为本类对象（猫是不能变成狗的）。</li>
</ul>
</blockquote>
<p>为什么要向下转型</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(</span><span class="n">Animal</span> <span class="n">a</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">Dog</span><span class="p">){</span>  
        <span class="n">Dog</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dog</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
        <span class="n">d</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
        <span class="n">d</span><span class="p">.</span><span class="na">run</span><span class="p">();</span><span class="c1">//狗有一个跑的方法      </span>
    <span class="p">}</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">Cat</span><span class="p">){</span>  
        <span class="n">Cat</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cat</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我也想跑，但是不会&quot;</span><span class="p">);</span> <span class="c1">//猫会抱怨    </span>
    <span class="p">}</span> 
    <span class="n">a</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span><span class="c1">//其他动物只会吃</span>
<span class="p">}</span>

<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">());</span>
<span class="n">eat</span><span class="p">(</span><span class="k">new</span> <span class="n">Dog</span><span class="p">());</span>
<span class="c1">//.....</span>
</pre></div>
<h1>this | super | final | static关键字</h1>
<h2>this</h2>
<ul>
<li>本类成员方法中，访问<strong>本类</strong>的成员变量。</li>
<li>本类成员方法中，访问<strong>本类</strong>的另一个成员方法。</li>
<li>本类的构造方法中，访问<strong>本类</strong>的另一个构造方法。</li>
</ul>
<p><figure><img data-width="945" data-height="463" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/40b2317328456c1863313da7e6978822.png" alt="" /></figure></p>
<h2>super</h2>
<ul>
<li>子类的成员方法中，访问<strong>父类</strong>的成员变量。</li>
<li>子类的成员方法中，访问<strong>父类</strong>的成员方法。</li>
<li>子类的构造方法中，访问<strong>父类</strong>的构造方法。</li>
</ul>
<p><figure><img data-width="955" data-height="520" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/a330aabcdf7a7ff4e55e31c10bd850f5.png" alt="" /></figure></p>
<p><strong>注意</strong></p>
<ul>
<li>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。</li>
<li>this与super不能同时存在。</li>
</ul>
<h2>final</h2>
<p><figure><img data-width="792" data-height="440" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/766c6ad905f4ec524f79aa59c2c43ab7.png" alt="" /></figure></p>
<p><figure><img data-width="965" data-height="290" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/7dd5e7b872f9729d7ae35d638ef51504.png" alt="" /></figure></p>
<h2>static</h2>
<p><figure><img data-width="963" data-height="323" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/cadae2b13731450515c64ae27948c3aa.png" alt="" /></figure></p>
<h3>Java中是否可以覆盖(override)一个<code>private</code>或者是<code>static</code>的方法？</h3>
<p>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p>
<h3>是否可以在<code>static</code>环境中访问<code>非static</code>变量？</h3>
<p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h1>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h1>
<h2>Java String 类：String字符串常量</h2>
<p>需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成<strong>新的String对象</strong>，这样不仅效率低下，而且大量浪费有限的内存空间。我们来看一下这张对String操作时内存变化的图：</p>
<p><figure><img data-width="723" data-height="231" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/5db91e25835b7dd1cd632f88792fef53.png" alt="" /></figure></p>
<p>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，<strong>这样短短的两个字符串，却需要开辟三次内存空间</strong>，不得不说这是对内存空间的<strong>极大浪费</strong>。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</p>
<h2>StringBuffer 和 StringBuilder 类——StringBuffer、StringBuilder字符串变量</h2>
<p><figure><img data-width="669" data-height="378" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/6bdf860e2216af59b14ae4594a8a0deb.png" alt="" /></figure></p>
<p>当对字符串进行修改的时候，需要使用 <strong>StringBuffer(线程安全)</strong> 和 <strong>StringBuilder(线程不安全)</strong> 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 <strong>StringBuilder 的方法不是线程安全的（不能同步访问）</strong>。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<p><figure><img data-width="472" data-height="417" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/b94c451ccb4f736feaff90f63a51a207.png" alt="" /></figure></p>
<h2>区别</h2>
<ul>
<li><strong>String：</strong>不可变字符串；</li>
<li><strong>StringBuffer：</strong>可变字符串、效率低、线程安全；</li>
<li><strong>StringBuilder：</strong>可变字符序列、效率高、线程不安全；</li>
</ul>
<p>初始化上的区别，String可以空赋值，后者不行，报错</p>
<p><figure><img data-width="676" data-height="256" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/9214ff2b052e94d8c8e37660994f0f72.png" alt="" /></figure></p>
<p><figure><img data-width="649" data-height="357" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/e25f12eec33e4be64109cf79ca7c881d.png" alt="" /></figure></p>
<h1>装箱与拆箱</h1>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<p><figure><img data-width="772" data-height="642" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/8e04b140daa6b856ac471baf41b1c76a.png" alt="" /></figure></p>
<p><figure><img data-width="966" data-height="555" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/3a6e33d9c72289d3ec40143f33783f76.png" alt="" /></figure></p>
<h2>面试题</h2>
<p><figure><img data-width="615" data-height="419" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/75b191b71b65866200fa95a5afe20899.png" alt="" /></figure></p>
<p>​       从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在<strong>[-128,127]</strong>之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>​       上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>
<p><figure><img data-width="614" data-height="379" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/a79e6e029a87f9038ee9acccdd072f9f.png" alt="" /></figure></p>
<p><figure><img data-width="639" data-height="94" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/33487f286e90e5b203b921404feb58d1.png" alt="" /></figure></p>
<h1>在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤</h1>
<p>​       Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ <strong>super()</strong> 来调⽤⽗类特定的构造⽅法，则会调⽤ <strong>⽗类中“没有参数的构造⽅法”</strong>。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中 ⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找 不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。</p>
<h1>接⼝和抽象类</h1>
<p><figure><img data-width="787" data-height="745" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/9bb207522d74cb0da858e9a3b2296979.png" alt="" /></figure></p>
<p><figure><img data-width="649" data-height="468" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/80b193c34b2d086b4c16381827fdeeca.png" alt="" /></figure></p>
<p><figure><img data-width="726" data-height="188" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/739c48564080012e87baafaa27243d6b.png" alt="" /></figure></p>
<h1>成员变量与局部变量的区别有哪些？</h1>
<p><figure><img data-width="642" data-height="390" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/f41b5a00a488a5bb030e9936fb2c7510.png" alt="" /></figure></p>
<h1>静态⽅法和实例⽅法有何不同</h1>
<ul>
<li>在外部调用静态方法时，可以使用<strong>"类名.方法名"</strong>的方式，也可以使用<strong>"对象名.方法名"</strong>的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ul>
<h1>==与equals()</h1>
<p><figure><img data-width="656" data-height="928" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/1b7fb6fb30bcbab095fd074cea048bdc.png" alt="" /></figure></p>
<h1>hashcode()与equals()</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/zj15527620802/article/details/88547914">https://blog.csdn.net/zj15527620802/article/details/88547914</a></li>
<li><a href="https://www.cnblogs.com/chenpi/p/5489494.html">equals()和hashCode()之间的关系</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li>
</ul>
</blockquote>
<h2>第一种 不会创建“类对应的散列表”</h2>
<h1>为什么 Java 中只有值传递？</h1>
<p>参考</p>
<blockquote><p><a href="https://blog.csdn.net/bjweimengshu/article/details/79799485">https://blog.csdn.net/bjweimengshu/article/details/79799485</a></p>
</blockquote>
<h1>Java中异常处理</h1>
<p>参考</p>
<blockquote><p><a href="https://blog.csdn.net/sugar_no1/article/details/88593255">https://blog.csdn.net/sugar_no1/article/details/88593255</a></p>
</blockquote>
<p><figure><img data-width="815" data-height="487" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/fd1c7b79705d7a588b9f41419e8f6376.png" alt="" /></figure></p>
<p><figure><img data-width="830" data-height="447" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/ca217f5fec24f2060b557cb55df73b94.png" alt="" /></figure></p>
<p><figure><img data-width="817" data-height="646" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/d81fe61de7d7ab0ebb567364d55ccb95.png" alt="" /></figure></p>
<p><figure><img data-width="829" data-height="411" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/633321d8b22037b633208d6babd81ef5.png" alt="" /></figure></p>
<h2>异常处理的三种方式</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/qq_22067469/article/details/82930798">https://blog.csdn.net/qq_22067469/article/details/82930798</a></li>
</ul>
</blockquote>
<h2>StackOverFlow的几种</h2>
<h3>1. 系统自动抛出异常</h3>
<p>当程序语句出现一些逻辑错误、主义错误或者类型转换错误时，系统会自动抛出异常</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>运行结果</p>
<div class="highlight"><pre><span></span><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">ArithmeticException</span><span class="p">:</span> <span class="o">/</span> <span class="n">by</span> <span class="n">zero</span>
    <span class="n">at</span> <span class="n">io</span><span class="p">.</span><span class="na">renren</span><span class="p">.</span><span class="na">modules</span><span class="p">.</span><span class="na">sys</span><span class="p">.</span><span class="na">controller</span><span class="p">.</span><span class="na">SysUserController</span><span class="p">.</span><span class="na">main</span><span class="p">(</span><span class="n">SysUserController</span><span class="p">.</span><span class="na">java</span><span class="p">:</span><span class="mi">154</span><span class="p">)</span>
</pre></div>
<h3>3. try{ } catch{}抛出异常</h3>
<p>在try中放入待执行代码，如果程序正常运行就会执行try中的代码，如果出现异常，就会执行catch中的代码，当然，try后面可以跟多个catch，当通过try catch这种方法抛出异常的时候要注意抛出异常的顺序，异常范围小的放在前面，异常范围大的放在后面，在这里举个例子：</p>
<div class="highlight"><pre><span></span><span class="k">try</span><span class="p">{</span>
                  <span class="c1">//待执行的代码</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;找不到文件&quot;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;IO操作失败&quot;</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>
<h3>4. throw</h3>
<p>throw是语句抛出一个异常，一般是在代码的内部，当程序出现某种逻辑错误时同程序主动抛出某种特定类型的异常</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;NBA&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;NBA&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NumberFormatException</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>5. throws</h3>
<p>throws是方法可能会抛出一个异常(用在<code>声明方法</code>时，表示该方法可能要抛出异常),当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testThrows</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">NumberFormatException</span> <span class="p">{</span>
    <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;NBA&quot;</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">parseInt</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">testThrows</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">NumberFormatException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;非数直类型不能强制类型转换&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>throw与throws的比较</h3>
<ul>
<li>throws出现在方法函数头，而throw出现在函数体。</li>
<li>throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</li>
<li>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ul>
<h3>编程习惯</h3>
<ul>
<li>在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；</li>
<li>用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();</li>
<li>如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；</li>
<li>如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。</li>
</ul>
<h1>获取⽤键盘输⼊常⽤的两种⽅法</h1>
<p><figure><img data-width="811" data-height="339" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/e2a1a62aa5dccc7e26e905dce17c3bcc.png" alt="" /></figure></p>
<h2>输入一个字符</h2>
<div class="highlight"><pre><span></span><span class="n">Scanner</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="na">next</span><span class="p">().</span><span class="na">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
<h2>next()和nextLine()</h2>
<ul>
<li><strong>next()：</strong>不可以读取空格。它不能读两个由空格或符号隔开的单词。此外，next()在读取输入后将光标放在同一行中。(next()只读空格之前的数据,并且光标指向本行)</li>
<li><strong>nextLine()：</strong>可以读取空格，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行。</li>
</ul>
<h1>泛型使用</h1>
<p>参考</p>
<blockquote><p><a href="https://www.cnblogs.com/jpfss/p/9928747.html">https://www.cnblogs.com/jpfss/p/9928747.html</a></p>
</blockquote>
<h1>浅拷贝 | 深拷贝</h1>
<ul>
<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址</li>
<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</li>
</ul>
<h1>String</h1>
<h2>String常用方法</h2>
<blockquote><ul>
<li><a href="https://wiki.lifeisgg.online/archives/Java-方法汇总/#toc_28">String常用方法</a></li>
</ul>
</blockquote>
<h2>两种方式创建的底层原理和字符串常量</h2>
<ul>
<li><p>第一种是通过<strong>“字面量”</strong>赋值</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="s">&quot;hello&quot;</span>
</pre></div>
</li>
<li><p>第二种是通过<strong>new关键字创建新对象</strong>，在内存中用构造器创建新对象形式</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</li>
</ul>
<h3>案例一：通过字面量来创建String</h3>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// True</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">s2</span><span class="p">));</span> <span class="c1">// True</span>
</pre></div>
<p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在"abc"这个对象，此时有两种情况</p>
<ul>
<li>如果不存在，则在字符串常量池中创建"abc"这个对象，然后将池中"abc"这个对象的引用地址返回给"abc"对象的引用s1，这样s1会指向字符串常量池中"abc"这个字符串对象；</li>
<li>如果存在，则不创建任何对象，直接将池中"abc"这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的"abc"对象，所以结果为true。</li>
</ul>
<p>当相同的字符串被创建多次，内存中只保存一份字符串常量值，这就是字符串的"驻留"</p>
<h3>案例二：通过new对象形式</h3>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s3</span> <span class="o">==</span> <span class="n">s4</span><span class="p">);</span> <span class="c1">// False</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s3</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">s4</span><span class="p">));</span> <span class="c1">// True</span>
</pre></div>
<p>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有"xyz"这个字符串对象，</p>
<ul>
<li>如果有：则不在池中再去创建"xyz"这个对象了，直接在堆中创建一个"xyz"字符串对象，然后将堆中的这个"xyz"对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个"xyz"字符串对象；</li>
<li>如果没有：则首先在字符串池中创建一个"xyz"字符串对象，然后再在堆中创建一个"xyz"字符串对象，然后将堆中这个"xyz"字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个"xyz"字符串对象。s4则指向了堆中创建的另一个"xyz"字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。</li>
</ul>
<h3>案例三：创建了多少对象</h3>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="err">“</span><span class="n">xyz</span><span class="err">”</span><span class="p">);</span>
</pre></div>
<p>产生几个对象？一个或两个，如果常量池中原来没有 ”xyz”, 就是两个。</p>
<ul>
<li>常量池中没有 <code>”xyz”</code>：就先去字符串常量池创建，然后再去堆中创建实例，所以会创建两个对象</li>
<li>常量池中有 <code>”xyz”</code>：就直接去堆中创建实例，所以会创建一个对象</li>
</ul>
<h2>intern的实现原理（JDK1.8）</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span> <span class="nf">intern</span><span class="p">();</span>
</pre></div>
<h3>JDK6的intern()</h3>
<p><figure><img data-width="924" data-height="572" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/ce42a6894fb4e1ea0c2aa986013e6781.png" alt="" /></figure></p>
<h3>JDK7的intern()</h3>
<p><figure><img data-width="1125" data-height="506" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/1149e77bc5d9b69e8d784357d6b71dd6.png" alt="" /></figure></p>
<p>这个方法是一个 <code>native</code> 的方法，但注释写的非常明了。当调用 intern方法时：</p>
<ul>
<li>如果字符串常量池已经包含一个等于此String对象的字符串（值比较用equals(oject)方法确定），则返回池中的字符串对象的地址。</li>
<li>如果不包含，将此String对象添加到字符串常量池中为新的String对象，并返回字符串常量池中此新的String对象的引用</li>
</ul>
<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，<strong>如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</strong></p>
<h3>举例</h3>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;01&quot;</span><span class="p">);</span><span class="c1">//创建了&quot;str&quot;和&quot;01&quot;常量，但是没有创建&quot;str01&quot;常量</span>
<span class="n">str2</span><span class="p">.</span><span class="na">intern</span><span class="p">();</span>
<span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;str01&quot;</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str2</span><span class="o">==</span><span class="n">str1</span><span class="p">);</span><span class="c1">//true</span>
</pre></div>
<blockquote><ol>
<li>第一行：字符串常量池中生成"str"和"01"，在堆中创建两个String对象，相加后返回在堆为"str01"的新的String对象的引用，<strong>此时常量池没有"str01"对象，只有"str"和"01"</strong></li>
<li>第二行：调用intern()后，由于字符串常量池中不存在"str01"，所以复制str2地址引用到字符串常量池(1.7后的改动)</li>
<li>第三行：由于字符串常量池中已存在"str01"，所以str1指向已存在的，即st2所指向的对象</li>
<li>第四行：两个指向同一个对象所以结果为true</li>
</ol>
</blockquote>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">)</span><span class="o">+</span><span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;01&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;str01&quot;</span><span class="p">;</span>
<span class="n">str2</span><span class="p">.</span><span class="na">intern</span><span class="p">();</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str2</span><span class="o">==</span><span class="n">str1</span><span class="p">);</span><span class="c1">//false</span>
</pre></div>
<blockquote><ol>
<li>第一行：字符串常量池中生成"str"和"01"，在堆中创建两个String对象，相加后返回值为"str01"的新的String对象</li>
<li>第二行：由于字符串常量池不存在"str01"，所以此时在字符串常量池中创建新的对象</li>
<li>第三行：由于已经存在"str01"，所以不会把str2地址引用到字符串常量池，而是返回已经存在的"str01"对象的地址</li>
<li>第四行：由于str1指向字符串常量池对象，str2指向堆中的对象，所以返回false</li>
</ol>
</blockquote>
<h2>字符串相加原理</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/u010775025/article/details/86507090">https://blog.csdn.net/u010775025/article/details/86507090</a></li>
</ul>
</blockquote>
<h3>三种情况</h3>
<ul>
<li>两个或者两个以上的字符串常量相加，在预编译的时候“+”会被优化，相当于把字符串常量自动合成一个字符串常量</li>
<li>字符串对象的+操作其本质是new了StringBuilder对象进行append操作，拼接后调用toString()返回String对象</li>
<li><code>final</code>修饰的String在相加的时候等同于<code>字符串常量</code>直接相加，在编译后会直接替换成对应的值</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;Programming&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;Programming&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">&quot;Program&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">&quot;ming&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">&quot;Program&quot;</span> <span class="o">+</span> <span class="s">&quot;ming&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s6</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="n">s4</span><span class="p">;</span>
<span class="n">String</span> <span class="n">s7</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="s">&quot;ming&quot;</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s5</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s6</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s7</span><span class="p">);</span>
</pre></div>
<ul>
<li><p><strong>常量相加：</strong>全都是常量相加时，会在字符串常量池创建新对象，不会在堆中创建新的对象</p>
<p><figure><img data-width="863" data-height="245" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/63375975fd5a1a00680896a900a5fb6d.png" alt="" /></figure></p>
<p>第20~22行，我们通过对比知道，String s5 = "Program" + "ming";在被编译器优化成了String s5 = "Programming";</p>
<p>也可以得出字符串常量相加，不会用到<code>StringBuilder</code>对象，有一点要注意的是：字符串常量和字符串是不同的概念，字符串常量储存于方法区，而字符串储存于堆(heap)。</p>
</li>
</ul>
<ul>
<li><p>包含String对象的相加：操作其本质是new了StringBuilder对象进行append操作，拼接后调用toString()返回新的String对象</p>
<p><figure><img data-width="1025" data-height="172" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/18f4b396dd4c0917c1e2ca7af5966091.png" alt="" /></figure></p>
<blockquote><ol>
<li>第24行：使用new 了 StringBuider对象</li>
<li>第25行：进行StringBuider对象初始化</li>
<li>第26行：使用append() 方法拼接s3的内容</li>
<li>第27行：再使用append() 方法拼接s4的内容</li>
<li>第28行：最后调用toString() 返回String对象</li>
</ol>
</blockquote>
</li>
</ul>
<h3>特殊情况</h3>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="s">&quot;ja&quot;</span><span class="p">).</span><span class="na">append</span><span class="p">(</span><span class="s">&quot;va&quot;</span><span class="p">).</span><span class="na">toString</span><span class="p">();</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="na">intern</span><span class="p">()</span> <span class="o">==</span> <span class="n">s2</span><span class="p">);</span><span class="c1">//false</span>
</pre></div>
<p>常理认为，在执行<code>s2.intern()</code>时，由于字符串常量池中不存在，所以会复制引用s2到字符串常量池中去，最后对比指向同一个对象地址为<code>true</code>，但事实上<code>"java"</code>这个字符串在执行此语句之前，字符串常量池中已经存在此字符串</p>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/Spring框架面试题/">
                    <time>August 08 2020</time>
                    <span>Spring框架面试题</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/Java-基础知识笔记/">
                    <time>August 08 2020</time>
                    <span>Java-基础知识笔记</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u7565\u61c2"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 ze</span>
                        
    <span class="leancloud_visitors"
            id="/archives/Java-基础面试题/" 
            data-flag-title="Java-基础面试题">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>