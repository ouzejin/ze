<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,ZE,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="ze &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="ze &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/591f9f7764a8fd2466b8ba7b37e37a9e.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>Redis部署与基本使用 - ze</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="参考" />
<meta property="og:title" content="Redis部署与基本使用 - ze" />
<meta property="og:description" content="参考" />
<meta property="og:site_name" content="ze" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/Redis部署与基本使用/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-11-21T15:17:13-00.00" />
<meta name="twitter:title" content="Redis部署与基本使用 - ze" />
<meta name="twitter:description" content="参考" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/avatar.png">ze</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.ze.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.ze.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/ouzejin" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/ouzejin" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class="open "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><div class="open "><span><a href="/category/Redis/">Redis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Redis实现高并发秒杀系统/">Redis实现高并发秒杀系统</a></li><li class="current"><a href="/archives/Redis部署与基本使用/">Redis部署与基本使用</a></li><li class=""><a href="/archives/Redis实现单点登录/">Redis实现单点登录</a></li><li class=""><a href="/archives/Redis理论学习笔记/">Redis理论学习笔记</a></li></ul></div><li class=""><a href="/archives/SQL学习笔记/">SQL学习笔记</a></li><li class=""><a href="/archives/Mysql理论学习笔记/">Mysql理论学习笔记</a></li><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class=" "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-时间处理/">Java-时间处理</a></li><li class=""><a href="/archives/Java-反射/">Java-反射</a></li><li class=""><a href="/archives/Java-JDK8新特性/">Java-JDK8新特性</a></li><li class=""><a href="/archives/Java-IO/">Java-IO</a></li><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class=""><a href="/archives/Java-集合容器/">Java-集合容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class=""><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/腾讯云学习笔记/">腾讯云学习笔记</a></li><li class=""><a href="/archives/面试题整理/">面试题整理</a></li><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class=" "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Swagger使用/">Swagger使用</a></li><li class=""><a href="/archives/Lombok使用/">Lombok使用</a></li><li class=""><a href="/archives/Maven中依赖的scope总结/">Maven中依赖的scope总结</a></li><li class=""><a href="/archives/Devtools对Springboot热部署/">Devtools对Springboot热部署</a></li><li class=""><a href="/archives/IDEA配置Run Dashboard/">IDEA配置Run Dashboard</a></li><li class=""><a href="/archives/IDEA初始化SpringBoot项目+逆向工程+配置/">IDEA初始化SpringBoot项目+逆向工程+配置</a></li><li class=""><a href="/archives/EasyExcel导入导出Excel/">EasyExcel导入导出Excel</a></li><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/Mybatis/">Mybatis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Mybatis学习笔记/">Mybatis学习笔记</a></li><li class=""><a href="/archives/Mybatis逆向工程&Example类使用/">Mybatis逆向工程&Example类使用</a></li></ul></div><li class=""><a href="/archives/HttpServletrequest与HttpServletResponse/">HttpServletrequest与HttpServletResponse</a></li><li class=""><a href="/archives/SpringMVC基础&面试/">SpringMVC基础&面试</a></li><li class=""><a href="/archives/SpringMVC注解/">SpringMVC注解</a></li><li class=""><a href="/archives/Spring基础&面试/">Spring基础&面试</a></li><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/前端/">前端</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/JavaScript面试题/">JavaScript面试题</a></li><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法基础笔记/">数据结构&算法基础笔记</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.ze.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.ze.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/ouzejin">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/ouzejin">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">Redis部署与基本使用</h1>
        <p class="post-meta">
            <time>November 21 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/数据库/">#数据库</a>
                </span>
                
                <span>
                    <a href="/tag/Redis/">#Redis</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h2>参考</h2>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟笔记Redis</a></li>
</ul>
</blockquote>
<h2>1. Redis安装</h2>
<h3>使用Docker在Linux下安装</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/docker/docker-install-redis.html">https://www.runoob.com/docker/docker-install-redis.html</a></li>
</ul>
</blockquote>
<h3>以配置文件方式启动</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/weixin_42456466/article/details/87270959">https://blog.csdn.net/weixin_42456466/article/details/87270959</a></li>
</ul>
</blockquote>
<h3>修改密码</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/x-ll123/p/9717351.html">https://www.cnblogs.com/x-ll123/p/9717351.html</a></li>
</ul>
</blockquote>
<h3>使用RedisDesktopManager连接</h3>
<p>下载RedisDesktopManager后直接连接即可</p>
<p><figure><img data-width="1100" data-height="834" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/e4f9debe339cc9955837b4ed6bdce54a.jpg" alt="" /></figure></p>
<p>连接后</p>
<p><figure><img data-width="1100" data-height="834" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/89a1988c8e1404690ff45179e8022d9c.jpg" alt="" /></figure></p>
<h2>2. Redis性能测试redis-benchmark</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-benchmarks.html">https://www.runoob.com/redis/redis-benchmarks.html</a></li>
</ul>
</blockquote>
<p><code>Docker</code>中的<code>redis-benchmark</code>测试命令</p>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/jianjun_fei/article/details/95108694">https://blog.csdn.net/jianjun_fei/article/details/95108694</a></li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span>docker <span class="nb">exec</span> -it containerName/containerid redis-benchmark -h <span class="m">127</span>.0.0.1 -p <span class="m">6379</span> -c <span class="m">100</span> -n <span class="m">100000</span>
</pre></div>
<p><figure><img data-width="1224" data-height="352" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/2f2783d1890c98258636c62a3f7073ba.jpg" alt="" /></figure></p>
<h2>3. Redis基本命令使用</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://redis.io/commands">官方命令文档</a></li>
<li><a href="http://redisdoc.com/">redis中文文档</a></li>
<li><a href="https://www.runoob.com/redis/redis-commands.html">菜鸟</a></li>
</ul>
</blockquote>
<h3>数据库</h3>
<p>切换数据库</p>
<div class="highlight"><pre><span></span><span class="k">select</span> <span class="m">0</span>
<span class="k">select</span> <span class="m">1</span>
</pre></div>
<p>数据库大小(key数量)</p>
<div class="highlight"><pre><span></span>dbsize
</pre></div>
<p>清空当前数据库</p>
<div class="highlight"><pre><span></span>flushdb

<span class="c1">#清空所有</span>
flushall
</pre></div>
<h3>键Key</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></li>
</ul>
</blockquote>
<h4>查看所有key</h4>
<div class="highlight"><pre><span></span>keys *
</pre></div>
<h4>设置过期时间</h4>
<div class="highlight"><pre><span></span>expire <span class="o">[</span>key<span class="o">]</span> <span class="o">[</span>second<span class="o">]</span>
</pre></div>
<h4>查看剩余时间</h4>
<div class="highlight"><pre><span></span>ttl <span class="o">[</span>key<span class="o">]</span>
</pre></div>
<p>两种情况</p>
<blockquote><ul>
<li>-1：未设置过期时间</li>
<li>-2：已过期或不存在key</li>
</ul>
</blockquote>
<h4>查看key对应的value类型</h4>
<div class="highlight"><pre><span></span><span class="nb">type</span> key
</pre></div>
<h4>给某个key的value拼接</h4>
<div class="highlight"><pre><span></span>append <span class="o">[</span>key<span class="o">]</span> <span class="o">[</span>value<span class="o">]</span>
</pre></div>
<h4>获取key对应value的长度</h4>
<div class="highlight"><pre><span></span>strlen <span class="o">[</span>key<span class="o">]</span>
</pre></div>
<h4>根据range截取</h4>
<div class="highlight"><pre><span></span><span class="c1">#截取字符串[0,3]</span>
getrange <span class="o">[</span>key<span class="o">]</span> <span class="m">0</span> <span class="m">3</span>
</pre></div>
<h4>替换</h4>
<div class="highlight"><pre><span></span><span class="c1">#从0开始替换为value</span>
setrange <span class="o">[</span>key<span class="o">]</span> <span class="m">0</span> <span class="o">[</span>value<span class="o">]</span>
</pre></div>
<h4>对于value为integer类型的操作</h4>
<h5>自增长++</h5>
<div class="highlight"><pre><span></span>incr <span class="o">[</span>key<span class="o">]</span>
</pre></div>
<h5>自减小--</h5>
<div class="highlight"><pre><span></span>decr <span class="o">[</span>key<span class="o">]</span>
</pre></div>
<h5>指定增加大小</h5>
<div class="highlight"><pre><span></span>incrby <span class="o">[</span>key<span class="o">]</span> <span class="o">[</span>number<span class="o">]</span>
</pre></div>
<h5>指定减小大小</h5>
<div class="highlight"><pre><span></span>decrby <span class="o">[</span>key<span class="o">]</span> <span class="o">[</span>number<span class="o">]</span>
</pre></div>
<h3>List</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-lists.html">Redis 列表(List) | 菜鸟教程 (runoob.com)</a></li>
</ul>
</blockquote>
<h3>Set</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-sets.html">Redis 集合(Set) | 菜鸟教程 (runoob.com)</a></li>
</ul>
</blockquote>
<h3>Hash</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-hashes.html">Redis 哈希(Hash) | 菜鸟教程 (runoob.com)</a></li>
</ul>
</blockquote>
<h3>ZSet</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-sorted-sets.html">Redis 有序集合(sorted set) | 菜鸟教程 (runoob.com)</a></li>
</ul>
</blockquote>
<h3>Geospatial</h3>
<p>地图经纬度，底层是用ZSet，可以使用ZSet的命令</p>
<h3>Hyperloglog</h3>
<p>基数</p>
<h3>Bitmap</h3>
<p>二进制，可用于打卡等状态变化</p>
<h2>4. Redis事务</h2>
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<blockquote><ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
</blockquote>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<blockquote><ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
</blockquote>
<p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>
<div class="highlight"><pre><span></span>redis <span class="m">127</span>.0.0.1:6379&gt; MULTI
OK

redis <span class="m">127</span>.0.0.1:6379&gt; SET book-name <span class="s2">&quot;Mastering C++ in 21 days&quot;</span>
QUEUED

redis <span class="m">127</span>.0.0.1:6379&gt; GET book-name
QUEUED

redis <span class="m">127</span>.0.0.1:6379&gt; SADD tag <span class="s2">&quot;C++&quot;</span> <span class="s2">&quot;Programming&quot;</span> <span class="s2">&quot;Mastering Series&quot;</span>
QUEUED

redis <span class="m">127</span>.0.0.1:6379&gt; SMEMBERS tag
QUEUED

redis <span class="m">127</span>.0.0.1:6379&gt; EXEC
<span class="m">1</span><span class="o">)</span> OK
<span class="m">2</span><span class="o">)</span> <span class="s2">&quot;Mastering C++ in 21 days&quot;</span>
<span class="m">3</span><span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">3</span>
<span class="m">4</span><span class="o">)</span> <span class="m">1</span><span class="o">)</span> <span class="s2">&quot;Mastering Series&quot;</span>
   <span class="m">2</span><span class="o">)</span> <span class="s2">&quot;C++&quot;</span>
   <span class="m">3</span><span class="o">)</span> <span class="s2">&quot;Programming&quot;</span>
</pre></div>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<div class="highlight"><pre><span></span>redis <span class="m">127</span>.0.0.1:7000&gt; multi
OK
redis <span class="m">127</span>.0.0.1:7000&gt; <span class="nb">set</span> a aaa
QUEUED
redis <span class="m">127</span>.0.0.1:7000&gt; <span class="nb">set</span> b bbb
QUEUED
redis <span class="m">127</span>.0.0.1:7000&gt; <span class="nb">set</span> c ccc
QUEUED
redis <span class="m">127</span>.0.0.1:7000&gt; <span class="nb">exec</span>
<span class="m">1</span><span class="o">)</span> OK
<span class="m">2</span><span class="o">)</span> OK
<span class="m">3</span><span class="o">)</span> OK
</pre></div>
<p>如果在 <code>set b bbb</code> 处失败，<code>set a</code> 已成功不会回滚，<code>set c</code> 还会继续执行。</p>
<p>取消事务</p>
<div class="highlight"><pre><span></span>discard
</pre></div>
<h2>5. Redis用监视器实现锁</h2>
<p>开启一个线程，开启监视器监视key<code>money</code></p>
<div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt; get money
<span class="s2">&quot;1080&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt; watch money
OK
<span class="m">127</span>.0.0.1:6379&gt; multi
OK
<span class="m">127</span>.0.0.1:6379&gt; incrby money <span class="m">100</span>
QUEUED
</pre></div>
<p>在执行事务前修改前，用另一个线程修改<code>money</code>的值</p>
<div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt; get money
<span class="s2">&quot;1080&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt; <span class="nb">set</span> money <span class="m">2000</span>
OK
</pre></div>
<p>此时再执行第一个线程的事务，redis发现监视的值<code>money</code>被更改，不会执行关于<code>money</code>的操作</p>
<div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt; <span class="nb">exec</span>
<span class="o">(</span>nil<span class="o">)</span>
<span class="m">127</span>.0.0.1:6379&gt;
</pre></div>
<h3>原理</h3>
<p>watch相当于实现了<code>乐观锁</code></p>
<h2>6. Jedis操作Redis</h2>
<p>导入包</p>
<div class="highlight"><pre><span></span><span class="c">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>redis.clients<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>jedis<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>3.3.0<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.alibaba<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>fastjson<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>1.2.70<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
</pre></div>
<h3>测试连接</h3>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">pingTest</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jedis</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">6379</span><span class="p">);</span>
        <span class="c1">//密码验证</span>
        <span class="n">jedis</span><span class="p">.</span><span class="na">auth</span><span class="p">(</span><span class="s">&quot;123456&quot;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">jedis</span><span class="p">.</span><span class="na">ping</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>HashTest</h3>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestHash</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jedis</span><span class="p">(</span><span class="s">&quot;47.100.59.153&quot;</span><span class="p">,</span> <span class="mi">6379</span><span class="p">);</span>
        <span class="n">jedis</span><span class="p">.</span><span class="na">auth</span><span class="p">(</span><span class="s">&quot;0.00.0&quot;</span><span class="p">);</span>
        <span class="n">jedis</span><span class="p">.</span><span class="na">flushDB</span><span class="p">();</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;key1&quot;</span><span class="p">,</span><span class="s">&quot;value1&quot;</span><span class="p">);</span>
        <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;key2&quot;</span><span class="p">,</span><span class="s">&quot;value2&quot;</span><span class="p">);</span>
        <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;key3&quot;</span><span class="p">,</span><span class="s">&quot;value3&quot;</span><span class="p">);</span>
        <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;key4&quot;</span><span class="p">,</span><span class="s">&quot;value4&quot;</span><span class="p">);</span>
        <span class="c1">//添加名称为hash（key）的hash元素</span>
        <span class="n">jedis</span><span class="p">.</span><span class="na">hmset</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span><span class="n">map</span><span class="p">);</span>
        <span class="c1">//向名称为hash的hash中添加key为key5，value为value5元素</span>
        <span class="n">jedis</span><span class="p">.</span><span class="na">hset</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span> <span class="s">&quot;key5&quot;</span><span class="p">,</span> <span class="s">&quot;value5&quot;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有键值对为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hgetAll</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span><span class="c1">//return Map&lt;String,String&gt;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有键为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hkeys</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span><span class="c1">//return Set&lt;String&gt;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有值为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hvals</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span><span class="c1">//return List&lt;String&gt;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hincrBy</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span> <span class="s">&quot;key6&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有键值对为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hgetAll</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hincrBy</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span> <span class="s">&quot;key6&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有键值对为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hgetAll</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;删除一个或者多个键值对：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hdel</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span> <span class="s">&quot;key2&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash的所有键值对为：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hgetAll</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;散列hash中键值对的个数：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hlen</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;判断hash中是否存在key2：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hexists</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span><span class="s">&quot;key2&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;判断hash中是否存在key3：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hexists</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span><span class="s">&quot;key3&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;获取hash中的值：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hmget</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span><span class="s">&quot;key3&quot;</span><span class="p">));</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;获取hash中的值：&quot;</span><span class="o">+</span><span class="n">jedis</span><span class="p">.</span><span class="na">hmget</span><span class="p">(</span><span class="s">&quot;hash&quot;</span><span class="p">,</span><span class="s">&quot;key3&quot;</span><span class="p">,</span><span class="s">&quot;key4&quot;</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>7. SpringBoot整合Redis</h2>
<p>原先底层使用的是<code>jedis</code>，在Spring2.x后改为<code>lettuce</code></p>
<blockquote><ul>
<li>jedis：采用的直连,多个线程操作的话,是不安全的,如果想要避免不安全的,使用 <code>jedis pool</code>连接池!更像<code>BIO模式</code></li>
<li>lettuce：采用<code>netty</code>，实例可以再多个线程中进行共享,不存在线程不安全的情况!可以减少线程数据了,更像<code>NIO模式</code></li>
</ul>
</blockquote>
<h3>导入依赖</h3>
<p><code>pom.xml</code></p>
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="p">.</span><span class="na">springframework</span><span class="p">.</span><span class="na">boot</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">redis</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</pre></div>
<h3><code>application.yml</code>配置</h3>
<div class="highlight"><pre><span></span><span class="nt">spring</span><span class="p">:</span>
  <span class="c1">#reids相关配置</span>
  <span class="nt">redis</span><span class="p">:</span>
    <span class="c1">#redis服务器地址</span>
    <span class="nt">host</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">127.0.0.1</span>
    <span class="c1">#redis服务器端口</span>
    <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">6379</span>
    <span class="nt">database</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span>
    <span class="c1">#密码</span>
    <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">123456</span>
    <span class="nt">jedis</span><span class="p">:</span>
      <span class="nt">pool</span><span class="p">:</span>
        <span class="c1">#连接池最大连接数（使用负值表示没有限制）</span>
        <span class="nt">max-active</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
        <span class="c1">#连接池最大阻塞等待时间（使用负值表示没有限制）</span>
        <span class="nt">max-wait</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">-1</span>
        <span class="c1">#连接池中最大空闲连接</span>
        <span class="nt">max-idle</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">10</span>
        <span class="c1">#连接池中最小空闲连接</span>
        <span class="nt">min-idle</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1</span>
    <span class="c1"># 连接超时时间(毫秒)</span>
    <span class="nt">timeout</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1000</span>
</pre></div>
<h3>简单使用示例</h3>
<p><code>SpringbootDemoApplicationTests.java</code></p>
<div class="highlight"><pre><span></span><span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="p">;</span>


    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">redisTest</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="s">&quot;myKey&quot;</span><span class="p">,</span><span class="s">&quot;你好&quot;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="s">&quot;myKey&quot;</span><span class="p">));</span>

        <span class="cm">/*获得数据库对象*/</span>
        <span class="n">RedisConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">getConnectionFactory</span><span class="p">().</span><span class="na">getConnection</span><span class="p">();</span>
        <span class="n">conn</span><span class="p">.</span><span class="na">flushDb</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
<h3>序列化配置</h3>
<p><code>RedisAutoConfiguration.java</code></p>
<div class="highlight"><pre><span></span><span class="nd">@Configuration</span><span class="p">(</span>
  <span class="n">proxyBeanMethods</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">)</span>
<span class="nd">@ConditionalOnClass</span><span class="p">({</span><span class="n">RedisOperations</span><span class="p">.</span><span class="na">class</span><span class="p">})</span>
<span class="nd">@EnableConfigurationProperties</span><span class="p">({</span><span class="n">RedisProperties</span><span class="p">.</span><span class="na">class</span><span class="p">})</span>
<span class="nd">@Import</span><span class="p">({</span><span class="n">LettuceConnectionConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">,</span> <span class="n">JedisConnectionConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisAutoConfiguration</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="nf">RedisAutoConfiguration</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="nd">@Bean</span>
  <span class="nd">@ConditionalOnMissingBean</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;redisTemplate&quot;</span><span class="p">}</span>
  <span class="p">)</span> <span class="c1">//注解意思为当没有自定义redisTemplate使使用此bean，可以自定义来替换这个默认的</span>
  <span class="kd">public</span> <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="nf">redisTemplate</span><span class="p">(</span><span class="n">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="p">)</span> <span class="kd">throws</span> <span class="n">UnknownHostException</span> <span class="p">{</span>
    <span class="c1">// 默认的RedisTemplate没有过多地设置，redis对象都是需要序列化</span>
    <span class="c1">// 两个泛型都是object object 的类型，我们后使用需要强制转换&lt;String, Object&gt;</span>
    <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">template</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedisTemplate</span><span class="p">();</span>
    <span class="n">template</span><span class="p">.</span><span class="na">setConnectionFactory</span><span class="p">(</span><span class="n">redisConnectionFactory</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nd">@Bean</span>
  <span class="nd">@ConditionalOnMissingBean</span> <span class="c1">//由于string是最常使用的bean，所以这里单独定义一个string的redisTemplate</span>
  <span class="kd">public</span> <span class="n">StringRedisTemplate</span> <span class="nf">stringRedisTemplate</span><span class="p">(</span><span class="n">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="p">)</span> <span class="kd">throws</span> <span class="n">UnknownHostException</span> <span class="p">{</span>
    <span class="n">StringRedisTemplate</span> <span class="n">template</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringRedisTemplate</span><span class="p">();</span>
    <span class="n">template</span><span class="p">.</span><span class="na">setConnectionFactory</span><span class="p">(</span><span class="n">redisConnectionFactory</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">template</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><code>RedisTemplate.java</code></p>
<div class="highlight"><pre><span></span><span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">RedisSerializer</span><span class="o">&lt;?&gt;</span> <span class="n">defaultSerializer</span><span class="p">;</span>
<span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">ClassLoader</span> <span class="n">classLoader</span><span class="p">;</span>
<span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">RedisSerializer</span> <span class="n">keySerializer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">RedisSerializer</span> <span class="n">valueSerializer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">RedisSerializer</span> <span class="n">hashKeySerializer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nd">@Nullable</span>
<span class="kd">private</span> <span class="n">RedisSerializer</span> <span class="n">hashValueSerializer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>


<span class="c1">//这里默认使用的是JDK的序列化，可以自定义一个配置类使用JSON序列化</span>
<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">defaultSerializer</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="na">defaultSerializer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdkSerializationRedisSerializer</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">classLoader</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="na">classLoader</span> <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="na">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
<p>当没有序列化对象直接传对象作为<code>value</code>时会报错误<code>SerializationException</code></p>
<div class="highlight"><pre><span></span><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="n">RedisTemplate</span> <span class="n">redisTemplate</span><span class="p">;</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">redisTest_2</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">JsonProcessingException</span> <span class="p">{</span>
  <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="na">builder</span><span class="p">().</span><span class="na">uid</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="na">realName</span><span class="p">(</span><span class="s">&quot;realName&quot;</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>
  <span class="c1">// 当没有序列化对象时</span>
  <span class="c1">// String jsonUser = new ObjectMapper().writeValueAsString(user);</span>
  <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="s">&quot;user1&quot;</span><span class="p">,</span><span class="n">user</span><span class="p">);</span>
  <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="s">&quot;user1&quot;</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>
<p><figure><img data-width="1510" data-height="186" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/a7758455462d5d318811b887bed33d25.jpg" alt="" /></figure></p>
<h3>配置redisConfig类</h3>
<p><code>redisConfig.java</code></p>
<p>用于替换在<code>RedisAutoConfiguration</code>默认的<code>RedisTemplate</code></p>
<div class="highlight"><pre><span></span><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="p">{</span>

    <span class="cm">/*自定义RedisTemplate*/</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">RedisTemplate</span> <span class="nf">redisTemplate</span><span class="p">(</span><span class="n">RedisConnectionFactory</span> <span class="n">factory</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">setConnectionFactory</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>

        <span class="c1">// 使用Jackson2JsonRedisSerialize 替换默认序列化</span>
        <span class="n">Jackson2JsonRedisSerializer</span> <span class="n">jackson2JsonRedisSerializer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jackson2JsonRedisSerializer</span><span class="p">(</span><span class="n">Object</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
        <span class="n">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectMapper</span><span class="p">();</span>
        <span class="n">objectMapper</span><span class="p">.</span><span class="na">setVisibility</span><span class="p">(</span><span class="n">PropertyAccessor</span><span class="p">.</span><span class="na">ALL</span><span class="p">,</span> <span class="n">JsonAutoDetect</span><span class="p">.</span><span class="na">Visibility</span><span class="p">.</span><span class="na">ANY</span><span class="p">);</span>
        <span class="n">objectMapper</span><span class="p">.</span><span class="na">enableDefaultTyping</span><span class="p">(</span><span class="n">ObjectMapper</span><span class="p">.</span><span class="na">DefaultTyping</span><span class="p">.</span><span class="na">NON_FINAL</span><span class="p">);</span>
        <span class="n">jackson2JsonRedisSerializer</span><span class="p">.</span><span class="na">setObjectMapper</span><span class="p">(</span><span class="n">objectMapper</span><span class="p">);</span>

        <span class="c1">// 设置value的序列化规则和 key的序列化规则</span>
        <span class="n">StringRedisSerializer</span> <span class="n">stringRedisSerializer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringRedisSerializer</span><span class="p">();</span>
        <span class="c1">// key采用String的序列化方式</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">setKeySerializer</span><span class="p">(</span><span class="n">stringRedisSerializer</span><span class="p">);</span>
        <span class="c1">// hash的key也采用String的序列化方式</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">setHashKeySerializer</span><span class="p">(</span><span class="n">stringRedisSerializer</span><span class="p">);</span>
        <span class="c1">// value序列化方式采用jackson</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">setValueSerializer</span><span class="p">(</span><span class="n">jackson2JsonRedisSerializer</span><span class="p">);</span>
        <span class="c1">// hash的value也采用jackson</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">setHashValueSerializer</span><span class="p">(</span><span class="n">jackson2JsonRedisSerializer</span><span class="p">);</span>

        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">afterPropertiesSet</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>存储一个对象</p>
<div class="highlight"><pre><span></span><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">redisTest_2</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">JsonProcessingException</span> <span class="p">{</span>
  <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="na">builder</span><span class="p">().</span><span class="na">uid</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="na">realName</span><span class="p">(</span><span class="s">&quot;realName&quot;</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>
  <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="s">&quot;user5&quot;</span><span class="p">,</span><span class="n">user</span><span class="p">);</span>
  <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="s">&quot;user5&quot;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>存储在redis中的是已经序列化的字符串</p>
<p><figure><img data-width="688" data-height="295" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/72541914599758c3bdc71c7d83484fa0.jpg" alt="存储在Redis中序列化的User" /><figcaption>存储在Redis中序列化的User</figcaption></figure></p>
<p>取出来后会经过反序列化</p>
<p><figure><img data-width="1062" data-height="263" src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/archives/assets/688406cdb8d9a5ca05687ce0118265c9.jpg" alt="取出User并反序列化" /><figcaption>取出User并反序列化</figcaption></figure></p>
<h3>封装常用API到<code>RedisUtil</code></h3>
<p>::: demo RedisUtil.java</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.lifeisgg.springboot_demo.util</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.core.RedisTemplate</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.util.CollectionUtils</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @Project: springboot_demo</span>
<span class="cm"> * @Package: com.lifeisgg.springboot_demo.util</span>
<span class="cm"> * @ClassName: RedisUtil</span>
<span class="cm"> * @Author: Chen Long</span>
<span class="cm"> * @Description:</span>
<span class="cm"> * @Datetime: 2020/12/1  20:32</span>
<span class="cm"> */</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RedisUtil</span> <span class="p">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">RedisTemplate</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="p">;</span>

    <span class="c1">// =============================common============================</span>
    <span class="cm">/**</span>
<span class="cm">     * 指定缓存失效时间</span>
<span class="cm">     * @param key  键</span>
<span class="cm">     * @param time 时间(秒)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">expire</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">redisTemplate</span><span class="p">.</span><span class="na">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 根据key 获取过期时间</span>
<span class="cm">     * @param key 键 不能为null</span>
<span class="cm">     * @return 时间(秒) 返回0代表为永久有效</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getExpire</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">getExpire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 判断key是否存在</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     * @return true 存在 false不存在</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasKey</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">hasKey</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 删除缓存</span>
<span class="cm">     * @param key 可以传一个值 或多个</span>
<span class="cm">     */</span>
    <span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="n">String</span><span class="p">...</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">redisTemplate</span><span class="p">.</span><span class="na">delete</span><span class="p">(</span><span class="n">key</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">redisTemplate</span><span class="p">.</span><span class="na">delete</span><span class="p">(</span><span class="n">CollectionUtils</span><span class="p">.</span><span class="na">arrayToList</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// ============================String=============================</span>

    <span class="cm">/**</span>
<span class="cm">     * 普通缓存获取</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     * @return 值</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 普通缓存放入</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return true成功 false失败</span>
<span class="cm">     */</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">set</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 普通缓存放入并设置时间</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span>
<span class="cm">     * @return true成功 false 失败</span>
<span class="cm">     */</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">set</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 递增</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param delta 要增加几(大于0)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">incr</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;递增因子必须大于0&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">increment</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 递减</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param delta 要减少几(小于0)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">decr</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;递减因子必须大于0&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForValue</span><span class="p">().</span><span class="na">increment</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// ================================Map=================================</span>

    <span class="cm">/**</span>
<span class="cm">     * HashGet</span>
<span class="cm">     * @param key  键 不能为null</span>
<span class="cm">     * @param item 项 不能为null</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">hget</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 获取hashKey对应的所有键值</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     * @return 对应的多个键值</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="nf">hmget</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">entries</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * HashSet</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     * @param map 对应多个键值</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hmset</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">putAll</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * HashSet 并设置时间</span>
<span class="cm">     * @param key  键</span>
<span class="cm">     * @param map  对应多个键值</span>
<span class="cm">     * @param time 时间(秒)</span>
<span class="cm">     * @return true成功 false失败</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hmset</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">putAll</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 向一张hash表中放入数据,如果不存在将创建</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param item  项</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return true 成功 false失败</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hset</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * 向一张hash表中放入数据,如果不存在将创建</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param item  项</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span>
<span class="cm">     * @return true 成功 false失败</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hset</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 删除hash表中的值</span>
<span class="cm">     *</span>
<span class="cm">     * @param key  键 不能为null</span>
<span class="cm">     * @param item 项 可以使多个 不能为null</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hdel</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">delete</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 判断hash表中是否有该项的值</span>
<span class="cm">     *</span>
<span class="cm">     * @param key  键 不能为null</span>
<span class="cm">     * @param item 项 不能为null</span>
<span class="cm">     * @return true 存在 false不存在</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hHasKey</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">hasKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span>
<span class="cm">     *</span>
<span class="cm">     * @param key  键</span>
<span class="cm">     * @param item 项</span>
<span class="cm">     * @param by   要增加几(大于0)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">hincr</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">,</span> <span class="kt">double</span> <span class="n">by</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">increment</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">by</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * hash递减</span>
<span class="cm">     *</span>
<span class="cm">     * @param key  键</span>
<span class="cm">     * @param item 项</span>
<span class="cm">     * @param by   要减少记(小于0)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">hdecr</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">String</span> <span class="n">item</span><span class="p">,</span> <span class="kt">double</span> <span class="n">by</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForHash</span><span class="p">().</span><span class="na">increment</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="n">by</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// ============================set=============================</span>

    <span class="cm">/**</span>
<span class="cm">     * 根据key获取Set中的所有值</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">sGet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">members</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 根据value从一个set中查询,是否存在</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return true 存在 false不存在</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sHasKey</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">isMember</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将数据放入set缓存</span>
<span class="cm">     *</span>
<span class="cm">     * @param key    键</span>
<span class="cm">     * @param values 值 可以是多个</span>
<span class="cm">     * @return 成功个数</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sSet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将set数据放入缓存</span>
<span class="cm">     *</span>
<span class="cm">     * @param key    键</span>
<span class="cm">     * @param time   时间(秒)</span>
<span class="cm">     * @param values 值 可以是多个</span>
<span class="cm">     * @return 成功个数</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sSetAndTime</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">Long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 获取set缓存的长度</span>
<span class="cm">     *</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sGetSetSize</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">size</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 移除值为value的</span>
<span class="cm">     *</span>
<span class="cm">     * @param key    键</span>
<span class="cm">     * @param values 值 可以是多个</span>
<span class="cm">     * @return 移除的个数</span>
<span class="cm">     */</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">setRemove</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">Long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForSet</span><span class="p">().</span><span class="na">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ===============================list=================================</span>

    <span class="cm">/**</span>
<span class="cm">     * 获取list缓存的内容</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param start 开始</span>
<span class="cm">     * @param end   结束 0 到 -1代表所有值</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">lGet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">range</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 获取list缓存的长度</span>
<span class="cm">     *</span>
<span class="cm">     * @param key 键</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">lGetListSize</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">size</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 通过索引 获取list中的值</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">lGetIndex</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将list放入缓存</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lSet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">rightPush</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将list放入缓存</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @param time  时间(秒)</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lSet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">rightPush</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将list放入缓存</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lSet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">rightPushAll</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 将list放入缓存</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @param time  时间(秒)</span>
<span class="cm">     * @return</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lSet</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">rightPushAll</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 根据索引修改list中的某条数据</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param index 索引</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return</span>
<span class="cm">     */</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lUpdateIndex</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**</span>
<span class="cm">     * 移除N个值为value</span>
<span class="cm">     *</span>
<span class="cm">     * @param key   键</span>
<span class="cm">     * @param count 移除多少个</span>
<span class="cm">     * @param value 值</span>
<span class="cm">     * @return 移除的个数</span>
<span class="cm">     */</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">lRemove</span><span class="p">(</span><span class="n">String</span> <span class="n">key</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">Long</span> <span class="n">remove</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="p">.</span><span class="na">opsForList</span><span class="p">().</span><span class="na">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
<p>:::</p>
<h2>8. <code>redis.conf</code>详解</h2>
<p><code>redis.conf</code>官方下载地址</p>
<blockquote><ul>
<li><a href="http://download.redis.io/redis-stable/redis.conf">http://download.redis.io/redis-stable/redis.conf</a></li>
</ul>
</blockquote>
<h3>8.1 存储单位说明</h3>
<p>::: demo 存储单位说明</p>
<div class="highlight"><pre><span></span><span class="c1"># Redis configuration file example.</span>
<span class="c1">#</span>
<span class="c1"># Note that in order to read the configuration file, Redis must be</span>
<span class="c1"># started with the file path as first argument:</span>
<span class="c1">#</span>
<span class="c1"># ./redis-server /path/to/redis.conf</span>

<span class="c1"># Note on units: when memory size is needed, it is possible to specify</span>
<span class="c1"># it in the usual form of 1k 5GB 4M and so forth:</span>
<span class="c1">#</span>
<span class="c1"># 1k =&gt; 1000 bytes</span>
<span class="c1"># 1kb =&gt; 1024 bytes</span>
<span class="c1"># 1m =&gt; 1000000 bytes</span>
<span class="c1"># 1mb =&gt; 1024*1024 bytes</span>
<span class="c1"># 1g =&gt; 1000000000 bytes</span>
<span class="c1"># 1gb =&gt; 1024*1024*1024 bytes</span>
<span class="c1">#</span>
<span class="c1"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span>
</pre></div>
<p>:::</p>
<h3>8.2 网络配置</h3>
<p>::: demo 网络配置</p>
<div class="highlight"><pre><span></span><span class="c1">################################## NETWORK #####################################</span>

<span class="c1"># 绑定的IP</span>
<span class="nb">bind</span> <span class="m">127</span>.0.0.1

<span class="c1"># 保护模式是否开启，默认开启</span>
protected-mode yes

<span class="c1"># 端口号</span>
port <span class="m">6379</span>

<span class="c1"># TCP listen() backlog.</span>
<span class="c1">#</span>
<span class="c1"># In high requests-per-second environments you need a high backlog in order</span>
<span class="c1"># to avoid slow clients connection issues. Note that the Linux kernel</span>
<span class="c1"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span>
<span class="c1"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span>
<span class="c1"># in order to get the desired effect.</span>
tcp-backlog <span class="m">511</span>

<span class="c1"># Unix socket.</span>
<span class="c1">#</span>
<span class="c1"># Specify the path for the Unix socket that will be used to listen for</span>
<span class="c1"># incoming connections. There is no default, so Redis will not listen</span>
<span class="c1"># on a unix socket when not specified.</span>
<span class="c1">#</span>
<span class="c1"># unixsocket /tmp/redis.sock</span>
<span class="c1"># unixsocketperm 700</span>

<span class="c1"># Close the connection after a client is idle for N seconds (0 to disable)</span>
timeout <span class="m">0</span>

<span class="c1"># TCP keepalive.</span>
<span class="c1">#</span>
<span class="c1"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span>
<span class="c1"># of communication. This is useful for two reasons:</span>
<span class="c1">#</span>
<span class="c1"># 1) Detect dead peers.</span>
<span class="c1"># 2) Force network equipment in the middle to consider the connection to be</span>
<span class="c1">#    alive.</span>
<span class="c1">#</span>
<span class="c1"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span>
<span class="c1"># Note that to close the connection the double of the time is needed.</span>
<span class="c1"># On other kernels the period depends on the kernel configuration.</span>
<span class="c1">#</span>
<span class="c1"># A reasonable value for this option is 300 seconds, which is the new</span>
<span class="c1"># Redis default starting with Redis 3.2.1.</span>
tcp-keepalive <span class="m">300</span>
</pre></div>
<p>:::</p>
<h3>8.3 基本配置</h3>
<p>::: demo 基本配置</p>
<div class="highlight"><pre><span></span><span class="c1">################################# GENERAL #####################################</span>

<span class="c1"># 是否以守护进程的方式运行即后台运行，默认为no，需要改为yes</span>
daemonize no

<span class="c1"># 后台运行指定的pid文件</span>
pidfile /var/run/redis_6379.pid

<span class="c1"># 日志级别</span>
<span class="c1"># Specify the server verbosity level.</span>
<span class="c1"># This can be one of:</span>
<span class="c1"># debug (a lot of information, useful for development/testing)</span>
<span class="c1"># verbose (many rarely useful info, but not a mess like the debug level)</span>
<span class="c1"># notice (moderately verbose, what you want in production probably)</span>
<span class="c1"># warning (only very important / critical messages are logged)</span>
loglevel notice

<span class="c1"># 输入的日志位置文件名</span>
<span class="c1"># Specify the log file name. Also the empty string can be used to force</span>
<span class="c1"># Redis to log on the standard output. Note that if you use standard</span>
<span class="c1"># output for logging but daemonize, logs will be sent to /dev/null</span>
logfile <span class="s2">&quot;&quot;</span>

<span class="c1"># 数据库数量</span>
databases <span class="m">16</span>

<span class="c1"># 运行时显示redislogo</span>
always-show-logo yes
</pre></div>
<p>:::</p>
<h3>8.4 快照配置</h3>
<p>::: demo 快照配置</p>
<div class="highlight"><pre><span></span><span class="c1">################################ SNAPSHOTTING  ################################</span>
<span class="c1">#</span>
<span class="c1"># Save the DB on disk:</span>
<span class="c1">#</span>
<span class="c1">#   save &lt;seconds&gt; &lt;changes&gt;</span>
<span class="c1">#</span>
<span class="c1">#   Will save the DB if both the given number of seconds and the given</span>
<span class="c1">#   number of write operations against the DB occurred.</span>
<span class="c1">#</span>
<span class="c1">#   In the example below the behavior will be to save:</span>
<span class="c1">#   after 900 sec (15 min) if at least 1 key changed</span>
<span class="c1">#   after 300 sec (5 min) if at least 10 keys changed</span>
<span class="c1">#   after 60 sec if at least 10000 keys changed</span>
<span class="c1">#</span>
<span class="c1">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span>
<span class="c1">#</span>
<span class="c1">#   It is also possible to remove all the previously configured save</span>
<span class="c1">#   points by adding a save directive with a single empty string argument</span>
<span class="c1">#   like in the following example:</span>
<span class="c1">#</span>
<span class="c1">#   save &quot;&quot;</span>

<span class="c1"># 如果900s内,如果至少有一个1个key进行了修改,我们就进行持久化操作</span>
save <span class="m">900</span> <span class="m">1</span>
<span class="c1"># 如果.00s内,如果至少有一个10个key进行了修改,我们就进行持久化操作</span>
save <span class="m">300</span> <span class="m">10</span>
<span class="c1"># 如果60s内,如果至少有一个10000个key进行了修改,我们就进行持久化操作</span>
save <span class="m">60</span> <span class="m">10000</span>

<span class="c1"># By default Redis will stop accepting writes if RDB snapshots are enabled</span>
<span class="c1"># (at least one save point) and the latest background save failed.</span>
<span class="c1"># This will make the user aware (in a hard way) that data is not persisting</span>
<span class="c1"># on disk properly, otherwise chances are that no one will notice and some</span>
<span class="c1"># disaster will happen.</span>
<span class="c1">#</span>
<span class="c1"># If the background saving process will start working again Redis will</span>
<span class="c1"># automatically allow writes again.</span>
<span class="c1">#</span>
<span class="c1"># However if you have setup your proper monitoring of the Redis server</span>
<span class="c1"># and persistence, you may want to disable this feature so that Redis will</span>
<span class="c1"># continue to work as usual even if there are problems with disk,</span>
<span class="c1"># permissions, and so forth.</span>
<span class="c1"># 持久化操作失败是否还继续</span>
stop-writes-on-bgsave-error yes

<span class="c1"># Compress string objects using LZF when dump .rdb databases?</span>
<span class="c1"># By default compression is enabled as it&#39;s almost always a win.</span>
<span class="c1"># If you want to save some CPU in the saving child set it to &#39;no&#39; but</span>
<span class="c1"># the dataset will likely be bigger if you have compressible values or keys.</span>
<span class="c1"># 是否压缩rdb文件，是的话会消耗一定CPU资源</span>
rdbcompression yes

<span class="c1"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span>
<span class="c1"># This makes the format more resistant to corruption but there is a performance</span>
<span class="c1"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span>
<span class="c1"># for maximum performances.</span>
<span class="c1">#</span>
<span class="c1"># RDB files created with checksum disabled have a checksum of zero that will</span>
<span class="c1"># tell the loading code to skip the check.</span>
<span class="c1"># 保存rdb文件的时候是否校验rdb文件</span>
rdbchecksum yes

<span class="c1"># The filename where to dump the DB</span>
dbfilename dump.rdb

<span class="c1"># Remove RDB files used by replication in instances without persistence</span>
<span class="c1"># enabled. By default this option is disabled, however there are environments</span>
<span class="c1"># where for regulations or other security concerns, RDB files persisted on</span>
<span class="c1"># disk by masters in order to feed replicas, or stored on disk by replicas</span>
<span class="c1"># in order to load them for the initial synchronization, should be deleted</span>
<span class="c1"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span>
<span class="c1"># and RDB persistence disabled, otherwise is completely ignored.</span>
<span class="c1">#</span>
<span class="c1"># An alternative (and sometimes better) way to obtain the same effect is</span>
<span class="c1"># to use diskless replication on both master and replicas instances. However</span>
<span class="c1"># in the case of replicas, diskless is not always an option.</span>
rdb-del-sync-files no

<span class="c1"># The working directory.</span>
<span class="c1">#</span>
<span class="c1"># The DB will be written inside this directory, with the filename specified</span>
<span class="c1"># above using the &#39;dbfilename&#39; configuration directive.</span>
<span class="c1">#</span>
<span class="c1"># The Append Only File will also be created inside this directory.</span>
<span class="c1">#</span>
<span class="c1"># Note that you must specify a directory here, not a file name.</span>
<span class="c1"># rdb文件保存的目录</span>
dir ./
</pre></div>
<p>:::</p>
<h3>8.5 主从复制相关</h3>
<p>::: demo 主从复制相关</p>
<div class="highlight"><pre><span></span><span class="c1">################################# REPLICATION #################################</span>

<span class="c1"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span>
<span class="c1"># another Redis server. A few things to understand ASAP about Redis replication.</span>
<span class="c1">#</span>
<span class="c1">#   +------------------+      +---------------+</span>
<span class="c1">#   |      Master      | ---&gt; |    Replica    |</span>
<span class="c1">#   | (receive writes) |      |  (exact copy) |</span>
<span class="c1">#   +------------------+      +---------------+</span>
<span class="c1">#</span>
<span class="c1"># 1) Redis replication is asynchronous, but you can configure a master to</span>
<span class="c1">#    stop accepting writes if it appears to be not connected with at least</span>
<span class="c1">#    a given number of replicas.</span>
<span class="c1"># 2) Redis replicas are able to perform a partial resynchronization with the</span>
<span class="c1">#    master if the replication link is lost for a relatively small amount of</span>
<span class="c1">#    time. You may want to configure the replication backlog size (see the next</span>
<span class="c1">#    sections of this file) with a sensible value depending on your needs.</span>
<span class="c1"># 3) Replication is automatic and does not need user intervention. After a</span>
<span class="c1">#    network partition replicas automatically try to reconnect to masters</span>
<span class="c1">#    and resynchronize with them.</span>
<span class="c1">#</span>
<span class="c1"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span>

<span class="c1"># If the master is password protected (using the &quot;requirepass&quot; configuration</span>
<span class="c1"># directive below) it is possible to tell the replica to authenticate before</span>
<span class="c1"># starting the replication synchronization process, otherwise the master will</span>
<span class="c1"># refuse the replica request.</span>
<span class="c1">#</span>
<span class="c1"># masterauth &lt;master-password&gt;</span>
<span class="c1">#</span>
<span class="c1"># However this is not enough if you are using Redis ACLs (for Redis version</span>
<span class="c1"># 6 or greater), and the default user is not capable of running the PSYNC</span>
<span class="c1"># command and/or other commands needed for replication. In this case it&#39;s</span>
<span class="c1"># better to configure a special user to use with replication, and specify the</span>
<span class="c1"># masteruser configuration as such:</span>
<span class="c1">#</span>
<span class="c1"># masteruser &lt;username&gt;</span>
<span class="c1">#</span>
<span class="c1"># When masteruser is specified, the replica will authenticate against its</span>
<span class="c1"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span>

<span class="c1"># When a replica loses its connection with the master, or when the replication</span>
<span class="c1"># is still in progress, the replica can act in two different ways:</span>
<span class="c1">#</span>
<span class="c1"># 1) if replica-serve-stale-data is set to &#39;yes&#39; (the default) the replica will</span>
<span class="c1">#    still reply to client requests, possibly with out of date data, or the</span>
<span class="c1">#    data set may just be empty if this is the first synchronization.</span>
<span class="c1">#</span>
<span class="c1"># 2) If replica-serve-stale-data is set to &#39;no&#39; the replica will reply with</span>
<span class="c1">#    an error &quot;SYNC with master in progress&quot; to all commands except:</span>
<span class="c1">#    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,</span>
<span class="c1">#    UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,</span>
<span class="c1">#    HOST and LATENCY.</span>
<span class="c1">#</span>
replica-serve-stale-data yes

<span class="c1"># You can configure a replica instance to accept writes or not. Writing against</span>
<span class="c1"># a replica instance may be useful to store some ephemeral data (because data</span>
<span class="c1"># written on a replica will be easily deleted after resync with the master) but</span>
<span class="c1"># may also cause problems if clients are writing to it because of a</span>
<span class="c1"># misconfiguration.</span>
<span class="c1">#</span>
<span class="c1"># Since Redis 2.6 by default replicas are read-only.</span>
<span class="c1">#</span>
<span class="c1"># Note: read only replicas are not designed to be exposed to untrusted clients</span>
<span class="c1"># on the internet. It&#39;s just a protection layer against misuse of the instance.</span>
<span class="c1"># Still a read only replica exports by default all the administrative commands</span>
<span class="c1"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span>
<span class="c1"># security of read only replicas using &#39;rename-command&#39; to shadow all the</span>
<span class="c1"># administrative / dangerous commands.</span>
replica-read-only yes

<span class="c1"># Replication SYNC strategy: disk or socket.</span>
<span class="c1">#</span>
<span class="c1"># New replicas and reconnecting replicas that are not able to continue the</span>
<span class="c1"># replication process just receiving differences, need to do what is called a</span>
<span class="c1"># &quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span>
<span class="c1"># replicas.</span>
<span class="c1">#</span>
<span class="c1"># The transmission can happen in two different ways:</span>
<span class="c1">#</span>
<span class="c1"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span>
<span class="c1">#                 file on disk. Later the file is transferred by the parent</span>
<span class="c1">#                 process to the replicas incrementally.</span>
<span class="c1"># 2) Diskless: The Redis master creates a new process that directly writes the</span>
<span class="c1">#              RDB file to replica sockets, without touching the disk at all.</span>
<span class="c1">#</span>
<span class="c1"># With disk-backed replication, while the RDB file is generated, more replicas</span>
<span class="c1"># can be queued and served with the RDB file as soon as the current child</span>
<span class="c1"># producing the RDB file finishes its work. With diskless replication instead</span>
<span class="c1"># once the transfer starts, new replicas arriving will be queued and a new</span>
<span class="c1"># transfer will start when the current one terminates.</span>
<span class="c1">#</span>
<span class="c1"># When diskless replication is used, the master waits a configurable amount of</span>
<span class="c1"># time (in seconds) before starting the transfer in the hope that multiple</span>
<span class="c1"># replicas will arrive and the transfer can be parallelized.</span>
<span class="c1">#</span>
<span class="c1"># With slow disks and fast (large bandwidth) networks, diskless replication</span>
<span class="c1"># works better.</span>
repl-diskless-sync no

<span class="c1"># When diskless replication is enabled, it is possible to configure the delay</span>
<span class="c1"># the server waits in order to spawn the child that transfers the RDB via socket</span>
<span class="c1"># to the replicas.</span>
<span class="c1">#</span>
<span class="c1"># This is important since once the transfer starts, it is not possible to serve</span>
<span class="c1"># new replicas arriving, that will be queued for the next RDB transfer, so the</span>
<span class="c1"># server waits a delay in order to let more replicas arrive.</span>
<span class="c1">#</span>
<span class="c1"># The delay is specified in seconds, and by default is 5 seconds. To disable</span>
<span class="c1"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span>
repl-diskless-sync-delay <span class="m">5</span>

<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span>
<span class="c1"># does not immediately store an RDB on disk, it may cause data loss during</span>
<span class="c1"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span>
<span class="c1"># cause Redis to abort in case of I/O errors during the initial synchronization</span>
<span class="c1"># stage with the master. Use only if your do what you are doing.</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># Replica can load the RDB it reads from the replication link directly from the</span>
<span class="c1"># socket, or store the RDB to a file and read that file after it was completely</span>
<span class="c1"># received from the master.</span>
<span class="c1">#</span>
<span class="c1"># In many cases the disk is slower than the network, and storing and loading</span>
<span class="c1"># the RDB file may increase replication time (and even increase the master&#39;s</span>
<span class="c1"># Copy on Write memory and salve buffers).</span>
<span class="c1"># However, parsing the RDB file directly from the socket may mean that we have</span>
<span class="c1"># to flush the contents of the current database before the full rdb was</span>
<span class="c1"># received. For this reason we have the following options:</span>
<span class="c1">#</span>
<span class="c1"># &quot;disabled&quot;    - Don&#39;t use diskless load (store the rdb file to the disk first)</span>
<span class="c1"># &quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span>
<span class="c1"># &quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsing</span>
<span class="c1">#                 the data directly from the socket. note that this requires</span>
<span class="c1">#                 sufficient memory, if you don&#39;t have it, you risk an OOM kill.</span>
repl-diskless-load disabled

<span class="c1"># Replicas send PINGs to server in a predefined interval. It&#39;s possible to</span>
<span class="c1"># change this interval with the repl_ping_replica_period option. The default</span>
<span class="c1"># value is 10 seconds.</span>
<span class="c1">#</span>
<span class="c1"># repl-ping-replica-period 10</span>

<span class="c1"># The following option sets the replication timeout for:</span>
<span class="c1">#</span>
<span class="c1"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span>
<span class="c1"># 2) Master timeout from the point of view of replicas (data, pings).</span>
<span class="c1"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span>
<span class="c1">#</span>
<span class="c1"># It is important to make sure that this value is greater than the value</span>
<span class="c1"># specified for repl-ping-replica-period otherwise a timeout will be detected</span>
<span class="c1"># every time there is low traffic between the master and the replica. The default</span>
<span class="c1"># value is 60 seconds.</span>
<span class="c1">#</span>
<span class="c1"># repl-timeout 60</span>

<span class="c1"># Disable TCP_NODELAY on the replica socket after SYNC?</span>
<span class="c1">#</span>
<span class="c1"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span>
<span class="c1"># less bandwidth to send data to replicas. But this can add a delay for</span>
<span class="c1"># the data to appear on the replica side, up to 40 milliseconds with</span>
<span class="c1"># Linux kernels using a default configuration.</span>
<span class="c1">#</span>
<span class="c1"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span>
<span class="c1"># be reduced but more bandwidth will be used for replication.</span>
<span class="c1">#</span>
<span class="c1"># By default we optimize for low latency, but in very high traffic conditions</span>
<span class="c1"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span>
<span class="c1"># be a good idea.</span>
repl-disable-tcp-nodelay no

<span class="c1"># Set the replication backlog size. The backlog is a buffer that accumulates</span>
<span class="c1"># replica data when replicas are disconnected for some time, so that when a</span>
<span class="c1"># replica wants to reconnect again, often a full resync is not needed, but a</span>
<span class="c1"># partial resync is enough, just passing the portion of data the replica</span>
<span class="c1"># missed while disconnected.</span>
<span class="c1">#</span>
<span class="c1"># The bigger the replication backlog, the longer the replica can endure the</span>
<span class="c1"># disconnect and later be able to perform a partial resynchronization.</span>
<span class="c1">#</span>
<span class="c1"># The backlog is only allocated if there is at least one replica connected.</span>
<span class="c1">#</span>
<span class="c1"># repl-backlog-size 1mb</span>

<span class="c1"># After a master has no connected replicas for some time, the backlog will be</span>
<span class="c1"># freed. The following option configures the amount of seconds that need to</span>
<span class="c1"># elapse, starting from the time the last replica disconnected, for the backlog</span>
<span class="c1"># buffer to be freed.</span>
<span class="c1">#</span>
<span class="c1"># Note that replicas never free the backlog for timeout, since they may be</span>
<span class="c1"># promoted to masters later, and should be able to correctly &quot;partially</span>
<span class="c1"># resynchronize&quot; with other replicas: hence they should always accumulate backlog.</span>
<span class="c1">#</span>
<span class="c1"># A value of 0 means to never release the backlog.</span>
<span class="c1">#</span>
<span class="c1"># repl-backlog-ttl 3600</span>

<span class="c1"># The replica priority is an integer number published by Redis in the INFO</span>
<span class="c1"># output. It is used by Redis Sentinel in order to select a replica to promote</span>
<span class="c1"># into a master if the master is no longer working correctly.</span>
<span class="c1">#</span>
<span class="c1"># A replica with a low priority number is considered better for promotion, so</span>
<span class="c1"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span>
<span class="c1"># will pick the one with priority 10, that is the lowest.</span>
<span class="c1">#</span>
<span class="c1"># However a special priority of 0 marks the replica as not able to perform the</span>
<span class="c1"># role of master, so a replica with priority of 0 will never be selected by</span>
<span class="c1"># Redis Sentinel for promotion.</span>
<span class="c1">#</span>
<span class="c1"># By default the priority is 100.</span>
replica-priority <span class="m">100</span>

<span class="c1"># It is possible for a master to stop accepting writes if there are less than</span>
<span class="c1"># N replicas connected, having a lag less or equal than M seconds.</span>
<span class="c1">#</span>
<span class="c1"># The N replicas need to be in &quot;online&quot; state.</span>
<span class="c1">#</span>
<span class="c1"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span>
<span class="c1"># the last ping received from the replica, that is usually sent every second.</span>
<span class="c1">#</span>
<span class="c1"># This option does not GUARANTEE that N replicas will accept the write, but</span>
<span class="c1"># will limit the window of exposure for lost writes in case not enough replicas</span>
<span class="c1"># are available, to the specified number of seconds.</span>
<span class="c1">#</span>
<span class="c1"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span>
<span class="c1">#</span>
<span class="c1"># min-replicas-to-write 3</span>
<span class="c1"># min-replicas-max-lag 10</span>
<span class="c1">#</span>
<span class="c1"># Setting one or the other to 0 disables the feature.</span>
<span class="c1">#</span>
<span class="c1"># By default min-replicas-to-write is set to 0 (feature disabled) and</span>
<span class="c1"># min-replicas-max-lag is set to 10.</span>

<span class="c1"># A Redis master is able to list the address and port of the attached</span>
<span class="c1"># replicas in different ways. For example the &quot;INFO replication&quot; section</span>
<span class="c1"># offers this information, which is used, among other tools, by</span>
<span class="c1"># Redis Sentinel in order to discover replica instances.</span>
<span class="c1"># Another place where this info is available is in the output of the</span>
<span class="c1"># &quot;ROLE&quot; command of a master.</span>
<span class="c1">#</span>
<span class="c1"># The listed IP address and port normally reported by a replica is</span>
<span class="c1"># obtained in the following way:</span>
<span class="c1">#</span>
<span class="c1">#   IP: The address is auto detected by checking the peer address</span>
<span class="c1">#   of the socket used by the replica to connect with the master.</span>
<span class="c1">#</span>
<span class="c1">#   Port: The port is communicated by the replica during the replication</span>
<span class="c1">#   handshake, and is normally the port that the replica is using to</span>
<span class="c1">#   listen for connections.</span>
<span class="c1">#</span>
<span class="c1"># However when port forwarding or Network Address Translation (NAT) is</span>
<span class="c1"># used, the replica may actually be reachable via different IP and port</span>
<span class="c1"># pairs. The following two options can be used by a replica in order to</span>
<span class="c1"># report to its master a specific set of IP and port, so that both INFO</span>
<span class="c1"># and ROLE will report those values.</span>
<span class="c1">#</span>
<span class="c1"># There is no need to use both the options if you need to override just</span>
<span class="c1"># the port or the IP address.</span>
<span class="c1">#</span>
<span class="c1"># replica-announce-ip 5.5.5.5</span>
<span class="c1"># replica-announce-port 1234</span>
</pre></div>
<p>:::</p>
<h3>8.6 安全配置</h3>
<p>::: demo 安全配置</p>
<p>查看密码</p>
<div class="highlight"><pre><span></span>//密码为空时获取密码
config get requirepass

//结果
<span class="s2">&quot;requirepass&quot;</span>
<span class="s2">&quot;&quot;</span>
</pre></div>
<p>设置密码</p>
<div class="highlight"><pre><span></span>config <span class="nb">set</span> requirepass <span class="s2">&quot;123456&quot;</span>
</pre></div>
<p>密码登录</p>
<div class="highlight"><pre><span></span>auth <span class="m">123456</span>
</pre></div>
<p><code>redis.conf</code>设置密码</p>
<div class="highlight"><pre><span></span><span class="c1">################################## SECURITY ###################################</span>



<span class="c1"># IMPORTANT NOTE: starting with Redis 6 &quot;requirepass&quot; is just a compatibility</span>
<span class="c1"># layer on top of the new ACL system. The option effect will be just setting</span>
<span class="c1"># the password for the default user. Clients will still authenticate using</span>
<span class="c1"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span>
<span class="c1"># if they follow the new protocol: both will work.</span>
<span class="c1">#</span>
<span class="c1"># requirepass foobared</span>
<span class="c1"># 设置密码</span>
requirepass <span class="m">123456</span>
</pre></div>
<p>:::</p>
<h3>8.7 客户端限制</h3>
<p>::: demo 客户端限制</p>
<div class="highlight"><pre><span></span><span class="c1">################################### CLIENTS ####################################</span>

<span class="c1"># Set the max number of connected clients at the same time. By default</span>
<span class="c1"># this limit is set to 10000 clients, however if the Redis server is not</span>
<span class="c1"># able to configure the process file limit to allow for the specified limit</span>
<span class="c1"># the max number of allowed clients is set to the current file limit</span>
<span class="c1"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span>
<span class="c1">#</span>
<span class="c1"># Once the limit is reached Redis will close all the new connections sending</span>
<span class="c1"># an error &#39;max number of clients reached&#39;.</span>
<span class="c1">#</span>
<span class="c1"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span>
<span class="c1"># shared with the cluster bus: every node in the cluster will use two</span>
<span class="c1"># connections, one incoming and another outgoing. It is important to size the</span>
<span class="c1"># limit accordingly in case of very large clusters.</span>
<span class="c1"># 设置能连接的最大客户端数</span>
maxclients <span class="m">10000</span>
</pre></div>
<p>:::</p>
<h3>8.8 内存容量配置</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="http://www.511yj.com/centos-redis-key.html">redis 设置过期Key 的 maxmemory-policy 六种方式 | 511遇见 (511yj.com)</a></li>
</ul>
</blockquote>
<p>六种方式</p>
<blockquote><ul>
<li><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值） </li>
<li><strong>2、allkeys-lru ：</strong> 删除lru算法的key  </li>
<li><strong>3、volatile-random：</strong>随机删除即将过期key  </li>
<li><strong>4、allkeys-random：</strong>随机删除  </li>
<li><strong>5、volatile-ttl ：</strong> 删除即将过期的  </li>
<li><strong>6、noeviction ：</strong> 永不过期，返回错误</li>
</ul>
</blockquote>
<p>::: demo 内存容量配置</p>
<div class="highlight"><pre><span></span><span class="c1">############################## MEMORY MANAGEMENT ################################</span>


<span class="c1">#最大内存容量</span>
maxmemory &lt;bytes&gt;

<span class="c1"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span>
<span class="c1"># is reached. You can select one from the following behaviors:</span>
<span class="c1">#</span>
<span class="c1"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span>
<span class="c1"># allkeys-lru -&gt; Evict any key using approximated LRU.</span>
<span class="c1"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span>
<span class="c1"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span>
<span class="c1"># volatile-random -&gt; Remove a random key having an expire set.</span>
<span class="c1"># allkeys-random -&gt; Remove a random key, any key.</span>
<span class="c1"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span>
<span class="c1"># noeviction -&gt; Don&#39;t evict anything, just return an error on write operations.</span>
<span class="c1">#</span>
<span class="c1"># LRU means Least Recently Used</span>
<span class="c1"># LFU means Least Frequently Used</span>
<span class="c1">#</span>
<span class="c1"># Both LRU, LFU and volatile-ttl are implemented using approximated</span>
<span class="c1"># randomized algorithms.</span>
<span class="c1">#</span>
<span class="c1"># Note: with any of the above policies, Redis will return an error on write</span>
<span class="c1">#       operations, when there are no suitable keys for eviction.</span>
<span class="c1">#</span>
<span class="c1">#       At the date of writing these commands are: set setnx setex append</span>
<span class="c1">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span>
<span class="c1">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span>
<span class="c1">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span>
<span class="c1">#       getset mset msetnx exec sort</span>
<span class="c1">#</span>
<span class="c1"># The default is:</span>
<span class="c1"># 内存达到上限的处理策略</span>
maxmemory-policy noeviction

<span class="c1"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span>
<span class="c1"># algorithms (in order to save memory), so you can tune it for speed or</span>
<span class="c1"># accuracy. By default Redis will check five keys and pick the one that was</span>
<span class="c1"># used least recently, you can change the sample size using the following</span>
<span class="c1"># configuration directive.</span>
<span class="c1">#</span>
<span class="c1"># The default of 5 produces good enough results. 10 Approximates very closely</span>
<span class="c1"># true LRU but costs more CPU. 3 is faster but not very accurate.</span>
<span class="c1">#</span>
<span class="c1"># maxmemory-samples 5</span>

<span class="c1"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span>
<span class="c1"># (unless it is promoted to master after a failover or manually). It means</span>
<span class="c1"># that the eviction of keys will be just handled by the master, sending the</span>
<span class="c1"># DEL commands to the replica as keys evict in the master side.</span>
<span class="c1">#</span>
<span class="c1"># This behavior ensures that masters and replicas stay consistent, and is usually</span>
<span class="c1"># what you want, however if your replica is writable, or you want the replica</span>
<span class="c1"># to have a different memory setting, and you are sure all the writes performed</span>
<span class="c1"># to the replica are idempotent, then you may change this default (but be sure</span>
<span class="c1"># to understand what you are doing).</span>
<span class="c1">#</span>
<span class="c1"># Note that since the replica by default does not evict, it may end using more</span>
<span class="c1"># memory than the one set via maxmemory (there are certain buffers that may</span>
<span class="c1"># be larger on the replica, or data structures may sometimes take more memory</span>
<span class="c1"># and so forth). So make sure you monitor your replicas and make sure they</span>
<span class="c1"># have enough memory to never hit a real out-of-memory condition before the</span>
<span class="c1"># master hits the configured maxmemory setting.</span>
<span class="c1">#</span>
<span class="c1"># replica-ignore-maxmemory yes</span>

<span class="c1"># Redis reclaims expired keys in two ways: upon access when those keys are</span>
<span class="c1"># found to be expired, and also in background, in what is called the</span>
<span class="c1"># &quot;active expire key&quot;. The key space is slowly and interactively scanned</span>
<span class="c1"># looking for expired keys to reclaim, so that it is possible to free memory</span>
<span class="c1"># of keys that are expired and will never be accessed again in a short time.</span>
<span class="c1">#</span>
<span class="c1"># The default effort of the expire cycle will try to avoid having more than</span>
<span class="c1"># ten percent of expired keys still in memory, and will try to avoid consuming</span>
<span class="c1"># more than 25% of total memory and to add latency to the system. However</span>
<span class="c1"># it is possible to increase the expire &quot;effort&quot; that is normally set to</span>
<span class="c1"># &quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span>
<span class="c1"># system will use more CPU, longer cycles (and technically may introduce</span>
<span class="c1"># more latency), and will tolerate less already expired keys still present</span>
<span class="c1"># in the system. It&#39;s a tradeoff between memory, CPU and latency.</span>
<span class="c1">#</span>
<span class="c1"># active-expire-effort 1</span>
</pre></div>
<p>:::</p>
<h3>8.9 AOF配置</h3>
<p>::: demo AOF配置</p>
<div class="highlight"><pre><span></span><span class="c1"># 是否用AOF，默认为no</span>
appendonly no：

<span class="c1"># 持久化文件的名字</span>
appendfilename <span class="s2">&quot;appendonly.aof&quot;</span>

<span class="c1"># 以什么策略执行一次保存</span>
<span class="c1"># appendfsync always , 在每次修改后都会sync，消耗性能</span>
<span class="c1"># appendfsync everysec , 每秒sync一次，可能会丢失1s的数据</span>
appendfsync everysec
<span class="c1"># appendfsync no ， 不执行sync，速度最快</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">############################## APPEND ONLY MODE ###############################</span>

<span class="c1"># By default Redis asynchronously dumps the dataset on disk. This mode is</span>
<span class="c1"># good enough in many applications, but an issue with the Redis process or</span>
<span class="c1"># a power outage may result into a few minutes of writes lost (depending on</span>
<span class="c1"># the configured save points).</span>
<span class="c1">#</span>
<span class="c1"># The Append Only File is an alternative persistence mode that provides</span>
<span class="c1"># much better durability. For instance using the default data fsync policy</span>
<span class="c1"># (see later in the config file) Redis can lose just one second of writes in a</span>
<span class="c1"># dramatic event like a server power outage, or a single write if something</span>
<span class="c1"># wrong with the Redis process itself happens, but the operating system is</span>
<span class="c1"># still running correctly.</span>
<span class="c1">#</span>
<span class="c1"># AOF and RDB persistence can be enabled at the same time without problems.</span>
<span class="c1"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span>
<span class="c1"># with the better durability guarantees.</span>
<span class="c1">#</span>
<span class="c1"># Please check http://redis.io/topics/persistence for more information.</span>

<span class="c1"># 是否用AOF默认为no</span>
appendonly no

<span class="c1"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span>

<span class="c1"># 持久化文件的名字</span>
appendfilename <span class="s2">&quot;appendonly.aof&quot;</span>

<span class="c1"># The fsync() call tells the Operating System to actually write data on disk</span>
<span class="c1"># instead of waiting for more data in the output buffer. Some OS will really flush</span>
<span class="c1"># data on disk, some other OS will just try to do it ASAP.</span>
<span class="c1">#</span>
<span class="c1"># Redis supports three different modes:</span>
<span class="c1">#</span>
<span class="c1"># no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.</span>
<span class="c1"># always: fsync after every write to the append only log. Slow, Safest.</span>
<span class="c1"># everysec: fsync only one time every second. Compromise.</span>
<span class="c1">#</span>
<span class="c1"># The default is &quot;everysec&quot;, as that&#39;s usually the right compromise between</span>
<span class="c1"># speed and data safety. It&#39;s up to you to understand if you can relax this to</span>
<span class="c1"># &quot;no&quot; that will let the operating system flush the output buffer when</span>
<span class="c1"># it wants, for better performances (but if you can live with the idea of</span>
<span class="c1"># some data loss consider the default persistence mode that&#39;s snapshotting),</span>
<span class="c1"># or on the contrary, use &quot;always&quot; that&#39;s very slow but a bit safer than</span>
<span class="c1"># everysec.</span>
<span class="c1">#</span>
<span class="c1"># More details please check the following article:</span>
<span class="c1"># http://antirez.com/post/redis-persistence-demystified.html</span>
<span class="c1">#</span>
<span class="c1"># If unsure, use &quot;everysec&quot;.</span>

<span class="c1"># appendfsync always</span>
appendfsync everysec
<span class="c1"># appendfsync no</span>

<span class="c1"># When the AOF fsync policy is set to always or everysec, and a background</span>
<span class="c1"># saving process (a background save or AOF log background rewriting) is</span>
<span class="c1"># performing a lot of I/O against the disk, in some Linux configurations</span>
<span class="c1"># Redis may block too long on the fsync() call. Note that there is no fix for</span>
<span class="c1"># this currently, as even performing fsync in a different thread will block</span>
<span class="c1"># our synchronous write(2) call.</span>
<span class="c1">#</span>
<span class="c1"># In order to mitigate this problem it&#39;s possible to use the following option</span>
<span class="c1"># that will prevent fsync() from being called in the main process while a</span>
<span class="c1"># BGSAVE or BGREWRITEAOF is in progress.</span>
<span class="c1">#</span>
<span class="c1"># This means that while another child is saving, the durability of Redis is</span>
<span class="c1"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span>
<span class="c1"># possible to lose up to 30 seconds of log in the worst scenario (with the</span>
<span class="c1"># default Linux settings).</span>
<span class="c1">#</span>
<span class="c1"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span>
<span class="c1"># &quot;no&quot; that is the safest pick from the point of view of durability.</span>

no-appendfsync-on-rewrite no

<span class="c1"># Automatic rewrite of the append only file.</span>
<span class="c1"># Redis is able to automatically rewrite the log file implicitly calling</span>
<span class="c1"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span>
<span class="c1">#</span>
<span class="c1"># This is how it works: Redis remembers the size of the AOF file after the</span>
<span class="c1"># latest rewrite (if no rewrite has happened since the restart, the size of</span>
<span class="c1"># the AOF at startup is used).</span>
<span class="c1">#</span>
<span class="c1"># This base size is compared to the current size. If the current size is</span>
<span class="c1"># bigger than the specified percentage, the rewrite is triggered. Also</span>
<span class="c1"># you need to specify a minimal size for the AOF file to be rewritten, this</span>
<span class="c1"># is useful to avoid rewriting the AOF file even if the percentage increase</span>
<span class="c1"># is reached but it is still pretty small.</span>
<span class="c1">#</span>
<span class="c1"># Specify a percentage of zero in order to disable the automatic AOF</span>
<span class="c1"># rewrite feature.</span>

auto-aof-rewrite-percentage <span class="m">100</span>
auto-aof-rewrite-min-size 64mb

<span class="c1"># An AOF file may be found to be truncated at the end during the Redis</span>
<span class="c1"># startup process, when the AOF data gets loaded back into memory.</span>
<span class="c1"># This may happen when the system where Redis is running</span>
<span class="c1"># crashes, especially when an ext4 filesystem is mounted without the</span>
<span class="c1"># data=ordered option (however this can&#39;t happen when Redis itself</span>
<span class="c1"># crashes or aborts but the operating system still works correctly).</span>
<span class="c1">#</span>
<span class="c1"># Redis can either exit with an error when this happens, or load as much</span>
<span class="c1"># data as possible (the default now) and start if the AOF file is found</span>
<span class="c1"># to be truncated at the end. The following option controls this behavior.</span>
<span class="c1">#</span>
<span class="c1"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span>
<span class="c1"># the Redis server starts emitting a log to inform the user of the event.</span>
<span class="c1"># Otherwise if the option is set to no, the server aborts with an error</span>
<span class="c1"># and refuses to start. When the option is set to no, the user requires</span>
<span class="c1"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span>
<span class="c1"># the server.</span>
<span class="c1">#</span>
<span class="c1"># Note that if the AOF file will be found to be corrupted in the middle</span>
<span class="c1"># the server will still exit with an error. This option only applies when</span>
<span class="c1"># Redis will try to read more data from the AOF file but not enough bytes</span>
<span class="c1"># will be found.</span>
aof-load-truncated yes

<span class="c1"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span>
<span class="c1"># AOF file for faster rewrites and recoveries. When this option is turned</span>
<span class="c1"># on the rewritten AOF file is composed of two different stanzas:</span>
<span class="c1">#</span>
<span class="c1">#   [RDB file][AOF tail]</span>
<span class="c1">#</span>
<span class="c1"># When loading, Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span>
<span class="c1"># string and loads the prefixed RDB file, then continues loading the AOF</span>
<span class="c1"># tail.</span>
aof-use-rdb-preamble yes
</pre></div>

<pre><code>



################################ LUA SCRIPTING  ###############################

# Max execution time of a Lua script in milliseconds.
#
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
#
# When a long running script exceeds the maximum execution time only the
# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
# used to stop a script that did not yet call any write commands. The second
# is the only way to shut down the server in the case a write command was
# already issued by the script but the user doesn't want to wait for the natural
# termination of the script.
#
# Set it to 0 or a negative value for unlimited execution without warnings.
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################

# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes can. In order to start a Redis instance as a
# cluster node enable the cluster support uncommenting the following:
#
# cluster-enabled yes

# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
#
# cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
# Most other internal time limits are a multiple of the node timeout.
#
# cluster-node-timeout 15000

# A replica of a failing master will avoid to start a failover if its data
# looks too old.
#
# There is no simple way for a replica to actually have an exact measure of
# its "data age", so the following two checks are performed:
#
# 1) If there are multiple replicas able to failover, they exchange messages
#    in order to try to give an advantage to the replica with the best
#    replication offset (more data from the master processed).
#    Replicas will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#
# 2) Every single replica computes the time of the last interaction with
#    its master. This can be the last ping or command received (if the master
#    is still in the "connected" state), or the time that elapsed since the
#    disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the replica will not try to failover
#    at all.
#
# The point "2" can be tuned by user. Specifically a replica will not perform
# the failover if, since the last interaction with the master, the time
# elapsed is greater than:
#
#   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period
#
# So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor
# is 10, and assuming a default repl-ping-replica-period of 10 seconds, the
# replica will not try to failover if it was not able to talk with the master
# for longer than 310 seconds.
#
# A large cluster-replica-validity-factor may allow replicas with too old data to failover
# a master, while a too small value may prevent the cluster from being able to
# elect a replica at all.
#
# For maximum availability, it is possible to set the cluster-replica-validity-factor
# to a value of 0, which means, that replicas will always try to failover the
# master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their
# offset rank).
#
# Zero is the only value able to guarantee that when all the partitions heal
# the cluster will always be able to continue.
#
# cluster-replica-validity-factor 10

# Cluster replicas are able to migrate to orphaned masters, that are masters
# that are left without working replicas. This improves the cluster ability
# to resist to failures as otherwise an orphaned master can't be failed over
# in case of failure if it has no working replicas.
#
# Replicas migrate to orphaned masters only if there are still at least a
# given number of other working replicas for their old master. This number
# is the "migration barrier". A migration barrier of 1 means that a replica
# will migrate only if there is at least 1 other working replica for its master
# and so forth. It usually reflects the number of replicas you want for every
# master in your cluster.
#
# Default is 1 (replicas migrate only if their masters remain with at least
# one replica). To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous
# in production.
#
# cluster-migration-barrier 1

# By default Redis Cluster nodes stop accepting queries if they detect there
# is at least a hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots
# are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still
# covered. In order to do so, just set the cluster-require-full-coverage
# option to no.
#
# cluster-require-full-coverage yes

# This option, when set to yes, prevents replicas from trying to failover its
# master during master failures. However the master can still perform a
# manual failover, if forced to do so.
#
# This is useful in different scenarios, especially in the case of multiple
# data center operations, where we want one side to never be promoted if not
# in the case of a total DC failure.
#
# cluster-replica-no-failover no

# This option, when set to yes, allows nodes to serve read traffic while the
# the cluster is in a down state, as long as it believes it owns the slots. 
#
# This is useful for two cases.  The first case is for when an application 
# doesn't require consistency of data during node failures or network partitions.
# One example of this is a cache, where as long as the node has the data it
# should be able to serve it. 
#
# The second use case is for configurations that don't meet the recommended  
# three shards but want to enable cluster mode and scale later. A 
# master outage in a 1 or 2 shard configuration causes a read/write outage to the
# entire cluster without this option set, with it set there is only a write outage.
# Without a quorum of masters, slot ownership will not change automatically. 
#
# cluster-allow-reads-when-down no

# In order to setup your cluster make sure to read the documentation
# available at http://redis.io web site.

########################## CLUSTER DOCKER/NAT support  ########################

# In certain deployments, Redis Cluster nodes address discovery fails, because
# addresses are NAT-ted or because ports are forwarded (the typical case is
# Docker and other containers).
#
# In order to make Redis Cluster working in such environments, a static
# configuration where each node knows its public address is needed. The
# following two options are used for this scope, and are:
#
# * cluster-announce-ip
# * cluster-announce-port
# * cluster-announce-bus-port
#
# Each instructs the node about its address, client port, and cluster message
# bus port. The information is then published in the header of the bus packets
# so that other nodes will be able to correctly map the address of the node
# publishing the information.
#
# If the above options are not used, the normal Redis Cluster auto-detection
# will be used instead.
#
# Note that when remapped, the bus port may not be at the fixed offset of
# clients port + 10000, so you can specify any port and bus-port depending
# on how they get remapped. If the bus-port is not set, a fixed offset of
# 10000 will be used as usual.
#
# Example:
#
# cluster-announce-ip 10.1.1.5
# cluster-announce-port 6379
# cluster-announce-bus-port 6380

################################## SLOW LOG ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command (this is the only
# stage of command execution where the thread is blocked and can not serve
# other requests in the meantime).
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.

# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while very small, can be measured under big load. Latency
# monitoring can easily be enabled at runtime using the command
# "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" if needed.
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################

# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key "foo" stored in the Database 0, two
# messages will be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.
#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  t     Stream commands
#  m     Key-miss events (Note: It is not included in the 'A' class)
#  A     Alias for g$lshzxet, so that the "AKE" string means all the events
#        (Except key-miss events which are excluded from 'A' due to their
#         unique nature).
#
#  The "notify-keyspace-events" takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled.
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel
#             name __keyevent@0__:expired use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
notify-keyspace-events ""

############################### GOPHER SERVER #################################

# Redis contains an implementation of the Gopher protocol, as specified in
# the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).
#
# The Gopher protocol was very popular in the late '90s. It is an alternative
# to the web, and the implementation both server and client side is so simple
# that the Redis server has just 100 lines of code in order to implement this
# support.
#
# What do you do with Gopher nowadays? Well Gopher never *really* died, and
# lately there is a movement in order for the Gopher more hierarchical content
# composed of just plain text documents to be resurrected. Some want a simpler
# internet, others believe that the mainstream internet became too much
# controlled, and it's cool to create an alternative space for people that
# want a bit of fresh air.
#
# Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol
# as a gift.
#
# --- HOW IT WORKS? ---
#
# The Redis Gopher support uses the inline protocol of Redis, and specifically
# two kind of inline requests that were anyway illegal: an empty request
# or any request that starts with "/" (there are no Redis commands starting
# with such a slash). Normal RESP2/RESP3 requests are completely out of the
# path of the Gopher protocol implementation and are served as usual as well.
#
# If you open a connection to Redis when Gopher is enabled and send it
# a string like "/foo", if there is a key named "/foo" it is served via the
# Gopher protocol.
#
# In order to create a real Gopher "hole" (the name of a Gopher site in Gopher
# talking), you likely need a script like the following:
#
#   https://github.com/antirez/gopher2redis
#
# --- SECURITY WARNING ---
#
# If you plan to put Redis on the internet in a publicly accessible address
# to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.
# Once a password is set:
#
#   1. The Gopher server (when enabled, not by default) will still serve
#      content via Gopher.
#   2. However other commands cannot be called before the client will
#      authenticate.
#
# So use the 'requirepass' option to protect your instance.
#
# Note that Gopher is not currently supported when 'io-threads-do-reads'
# is enabled.
#
# To enable Gopher support, uncomment the following line and set the option
# from no (the default) to yes.
#
# gopher-enabled no

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# -5: max size: 64 Kb  &lt;-- not recommended for normal workloads
# -4: max size: 32 Kb  &lt;-- not recommended
# -3: max size: 16 Kb  &lt;-- probably not recommended
# -2: max size: 8 Kb   &lt;-- good
# -1: max size: 4 Kb   &lt;-- good
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2

# Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 0: disable all list compression
# 1: depth 1 means "don't start compressing until after 1 node into the list,
#    going from either the head or tail"
#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]
#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,
#    but compress all nodes between them.
# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]
# etc.
list-compress-depth 0

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000

# Streams macro node max size / items. The stream data structure is a radix
# tree of big nodes that encode multiple items inside. Using this configuration
# it is possible to configure how big a single node can be in bytes, and the
# maximum number of items it may contain before switching to a new node when
# appending new stream entries. If any of the following settings are set to
# zero, the limit is ignored, so for instance it is possible to set just a
# max entires limit by setting max-bytes to 0 and max-entries to the desired
# value.
stream-node-max-bytes 4096
stream-node-max-entries 100

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply from time to time
# to queries with 2 milliseconds delay.
#
# use "activerehashing yes" if you don't have such hard requirements but
# want to free memory asap when possible.
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set differently for the three different classes of clients:
#
# normal -&gt; normal clients including MONITOR clients
# replica  -&gt; replica clients
# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern
#
# The syntax of every client-output-buffer-limit directive is the following:
#
# client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
#
# Instead there is a default limit for pubsub and replica clients, since
# subscribers and replicas receive data in a push fashion.
#
# Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Client query buffers accumulate new commands. They are limited to a fixed
# amount by default in order to avoid that a protocol desynchronization (for
# instance due to a bug in the client) will lead to unbound memory usage in
# the query buffer. However you can configure it here if you have very special
# needs, such us huge multi/exec requests or alike.
#
# client-query-buffer-limit 1gb

# In the Redis protocol, bulk requests, that are, elements representing single
# strings, are normally limited to 512 mb. However you can change this limit
# here, but must be 1mb or greater
#
# proto-max-bulk-len 512mb

# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10

# Normally it is useful to have an HZ value which is proportional to the
# number of clients connected. This is useful in order, for instance, to
# avoid too many clients are processed for each background task invocation
# in order to avoid latency spikes.
#
# Since the default HZ value by default is conservatively set to 10, Redis
# offers, and enables by default, the ability to use an adaptive HZ value
# which will temporarily raise when there are many connected clients.
#
# When dynamic HZ is enabled, the actual configured HZ will be used
# as a baseline, but multiples of the configured HZ value will be actually
# used as needed once more clients are connected. In this way an idle
# instance will use very little CPU time while a busy instance will be
# more responsive.
dynamic-hz yes

# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes

# When redis saves RDB file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
rdb-save-incremental-fsync yes

# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
# idea to start with the default settings and only change them after investigating
# how to improve the performances and how the keys LFU change over time, which
# is possible to inspect via the OBJECT FREQ command.
#
# There are two tunable parameters in the Redis LFU implementation: the
# counter logarithm factor and the counter decay time. It is important to
# understand what the two parameters mean before changing them.
#
# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
# uses a probabilistic increment with logarithmic behavior. Given the value
# of the old counter, when a key is accessed, the counter is incremented in
# this way:
#
# 1. A random number R between 0 and 1 is extracted.
# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
# 3. The counter is incremented only if R &lt; P.
#
# The default lfu-log-factor is 10. This is a table of how the frequency
# counter changes with a different number of accesses with different
# logarithmic factors:
#
# +--------+------------+------------+------------+------------+------------+
# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
# +--------+------------+------------+------------+------------+------------+
# | 0      | 104        | 255        | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 1      | 18         | 49         | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 10     | 10         | 18         | 142        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 100    | 8          | 11         | 49         | 143        | 255        |
# +--------+------------+------------+------------+------------+------------+
#
# NOTE: The above table was obtained by running the following commands:
#
#   redis-benchmark -n 1000000 incr foo
#   redis-cli object freq foo
#
# NOTE 2: The counter initial value is 5 in order to give new objects a chance
# to accumulate hits.
#
# The counter decay time is the time, in minutes, that must elapse in order
# for the key counter to be divided by two (or decremented if it has a value
# less &lt;= 10).
#
# The default value for the lfu-decay-time is 1. A special value of 0 means to
# decay the counter every time it happens to be scanned.
#
# lfu-log-factor 10
# lfu-decay-time 1

########################### ACTIVE DEFRAGMENTATION #######################
#
# What is active defragmentation?
# -------------------------------
#
# Active (online) defragmentation allows a Redis server to compact the
# spaces left between small allocations and deallocations of data in memory,
# thus allowing to reclaim back memory.
#
# Fragmentation is a natural process that happens with every allocator (but
# less so with Jemalloc, fortunately) and certain workloads. Normally a server
# restart is needed in order to lower the fragmentation, or at least to flush
# away all the data and create it again. However thanks to this feature
# implemented by Oran Agra for Redis 4.0 this process can happen at runtime
# in a "hot" way, while the server is running.
#
# Basically when the fragmentation is over a certain level (see the
# configuration options below) Redis will start to create new copies of the
# values in contiguous memory regions by exploiting certain specific Jemalloc
# features (in order to understand if an allocation is causing fragmentation
# and to allocate it in a better place), and at the same time, will release the
# old copies of the data. This process, repeated incrementally for all the keys
# will cause the fragmentation to drop back to normal values.
#
# Important things to understand:
#
# 1. This feature is disabled by default, and only works if you compiled Redis
#    to use the copy of Jemalloc we ship with the source code of Redis.
#    This is the default with Linux builds.
#
# 2. You never need to enable this feature if you don't have fragmentation
#    issues.
#
# 3. Once you experience fragmentation, you can enable this feature when
#    needed with the command "CONFIG SET activedefrag yes".
#
# The configuration parameters are able to fine tune the behavior of the
# defragmentation process. If you are not sure about what they mean it is
# a good idea to leave the defaults untouched.

# Enabled active defragmentation
# activedefrag no

# Minimum amount of fragmentation waste to start active defrag
# active-defrag-ignore-bytes 100mb

# Minimum percentage of fragmentation to start active defrag
# active-defrag-threshold-lower 10

# Maximum percentage of fragmentation at which we use maximum effort
# active-defrag-threshold-upper 100

# Minimal effort for defrag in CPU percentage, to be used when the lower
# threshold is reached
# active-defrag-cycle-min 1

# Maximal effort for defrag in CPU percentage, to be used when the upper
# threshold is reached
# active-defrag-cycle-max 25

# Maximum number of set/hash/zset/list fields that will be processed from
# the main dictionary scan
# active-defrag-max-scan-fields 1000

# Jemalloc background thread for purging will be enabled by default
jemalloc-bg-thread yes

# It is possible to pin different threads and processes of Redis to specific
# CPUs in your system, in order to maximize the performances of the server.
# This is useful both in order to pin different Redis threads in different
# CPUs, but also in order to make sure that multiple Redis instances running
# in the same host will be pinned to different CPUs.
#
# Normally you can do this using the "taskset" command, however it is also
# possible to this via Redis configuration directly, both in Linux and FreeBSD.
#
# You can pin the server/IO threads, bio threads, aof rewrite child process, and
# the bgsave child process. The syntax to specify the cpu list is the same as
# the taskset command:
#
# Set redis server/io threads to cpu affinity 0,2,4,6:
# server_cpulist 0-7:2
#
# Set bio threads to cpu affinity 1,3:
# bio_cpulist 1,3
#
# Set aof rewrite child process to cpu affinity 8,9,10,11:
# aof_rewrite_cpulist 8-11
#
# Set bgsave child process to cpu affinity 1,10,11
# bgsave_cpulist 1,10-11</code></pre>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/Redis实现高并发秒杀系统/">
                    <time>November 30 2020</time>
                    <span>Redis实现高并发秒杀系统</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/Redis实现单点登录/">
                    <time>November 08 2020</time>
                    <span>Redis实现单点登录</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u7565\u61c2"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 ze</span>
                        
    <span class="leancloud_visitors"
            id="/archives/Redis部署与基本使用/" 
            data-flag-title="Redis部署与基本使用">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/ouzejin/ze@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>