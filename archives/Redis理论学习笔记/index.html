<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,ZE,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="ze &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="ze &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/591f9f7764a8fd2466b8ba7b37e37a9e.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>Redis理论学习笔记 - ze</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="Redis学习笔记" />
<meta property="og:title" content="Redis理论学习笔记 - ze" />
<meta property="og:description" content="Redis学习笔记" />
<meta property="og:site_name" content="ze" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/Redis理论学习笔记/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-10-12T20:45:07-00.00" />
<meta name="twitter:title" content="Redis理论学习笔记 - ze" />
<meta name="twitter:description" content="Redis学习笔记" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/avatar.png">ze</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.ze.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.ze.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/ouzejin" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/ouzejin" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class="open "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><div class="open "><span><a href="/category/Redis/">Redis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Redis实现高并发秒杀系统/">Redis实现高并发秒杀系统</a></li><li class=""><a href="/archives/Redis部署与基本使用/">Redis部署与基本使用</a></li><li class=""><a href="/archives/Redis实现单点登录/">Redis实现单点登录</a></li><li class="current"><a href="/archives/Redis理论学习笔记/">Redis理论学习笔记</a></li></ul></div><li class=""><a href="/archives/SQL学习笔记/">SQL学习笔记</a></li><li class=""><a href="/archives/Mysql理论学习笔记/">Mysql理论学习笔记</a></li><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class=" "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-时间处理/">Java-时间处理</a></li><li class=""><a href="/archives/Java-反射/">Java-反射</a></li><li class=""><a href="/archives/Java-JDK8新特性/">Java-JDK8新特性</a></li><li class=""><a href="/archives/Java-IO/">Java-IO</a></li><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class=""><a href="/archives/Java-集合容器/">Java-集合容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class=""><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/腾讯云学习笔记/">腾讯云学习笔记</a></li><li class=""><a href="/archives/面试题整理/">面试题整理</a></li><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class=" "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Swagger使用/">Swagger使用</a></li><li class=""><a href="/archives/Lombok使用/">Lombok使用</a></li><li class=""><a href="/archives/Maven中依赖的scope总结/">Maven中依赖的scope总结</a></li><li class=""><a href="/archives/Devtools对Springboot热部署/">Devtools对Springboot热部署</a></li><li class=""><a href="/archives/IDEA配置Run Dashboard/">IDEA配置Run Dashboard</a></li><li class=""><a href="/archives/IDEA初始化SpringBoot项目+逆向工程+配置/">IDEA初始化SpringBoot项目+逆向工程+配置</a></li><li class=""><a href="/archives/EasyExcel导入导出Excel/">EasyExcel导入导出Excel</a></li><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/Mybatis/">Mybatis</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Mybatis学习笔记/">Mybatis学习笔记</a></li><li class=""><a href="/archives/Mybatis逆向工程&Example类使用/">Mybatis逆向工程&Example类使用</a></li></ul></div><li class=""><a href="/archives/HttpServletrequest与HttpServletResponse/">HttpServletrequest与HttpServletResponse</a></li><li class=""><a href="/archives/SpringMVC基础&面试/">SpringMVC基础&面试</a></li><li class=""><a href="/archives/SpringMVC注解/">SpringMVC注解</a></li><li class=""><a href="/archives/Spring基础&面试/">Spring基础&面试</a></li><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/前端/">前端</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/JavaScript面试题/">JavaScript面试题</a></li><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法基础笔记/">数据结构&算法基础笔记</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.ze.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.ze.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/ouzejin">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/ouzejin">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">Redis理论学习笔记</h1>
        <p class="post-meta">
            <time>October 12 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/数据库/">#数据库</a>
                </span>
                
                <span>
                    <a href="/tag/Redis/">#Redis</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><p>Redis学习笔记</p>
<h1>参考</h1>
<blockquote><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484858&amp;idx=1&amp;sn=8e222ea6115e0b69cac91af14d2caf36&amp;chksm=cea24a71f9d5c367148dccec3d5ddecf5ecd8ea096b5c5ec32f22080e66ac3c343e99151c9e0&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect">redis 总结——重构版</a></li>
<li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">https://www.cnblogs.com/jasontec/p/9699242.html</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></li>
<li><a href="http://redisdoc.com/">Redis中文文档</a></li>
<li><a href="https://www.bilibili.com/video/BV1S54y1R7SB">【狂神说Java】Redis最新超详细版教程通俗易懂</a></li>
</ul>
</blockquote>
<h1>简介</h1>
<p>Redis的全称是<code>Remote Dictionary Server</code>，即<code>远程字典服务</code>。官方原话如下：</p>
<p>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件MQ</code>。它支持多种类型的数据结构,如字符串( strings),散列( hashes),列表( lists),集合(sets),有序集合( sorted sets)与范围查询,bitmaps, hyperloglogs和地理空间( geospatial)索引半径查询。 Redis内置了复制( replication),LUA脚本(Luascripting),LRU驱动事件( LRU eviction),事务( transactions)和不同级别的磁盘持久化( persistence),并通过Reds哨兵( Sentinel)和自动分区( Cluster)提供高可用性( high availability)。</p>
<h2>优点</h2>
<p>因为是<code>纯内存</code>操作, Redis的性能非常出色,每秒可以处理超过<code>10万次读写操作</code>是已知性能最快的<code>Key- Value DB</code>。Redis的出色之处不仅仅是性能, Redis最大的魅力是支持保存<code>多种数据结构</code>,此外<code>单个value</code>的最大限制是<code>1GB</code>,不像 <code>memcached</code>只能保存<code>1MB</code>的数据,因此 Redis可以用来实现很多有用的功能。比方说用他的<code>Lst</code>来做<code>FIFO双向链表</code>,实现一个轻量级的高性能消息队列服务用他的Set可以做高性能的tag系统等等另外 Redis也可以对存入的<code>Key-Vaue</code>设置<code>expire</code>时间,因此也可以被当作一个功能加强版的 memcached来用。</p>
<h2>缺点</h2>
<p>Redis的主要缺点是<code>数据库容量</code>受到<code>物理内存</code>的限制,不能用作<code>海量数据的高性能读写</code>,因此 Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<p>简单来说 redis 就是⼀个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读 写速度⾮常快，因此 redis 被⼴泛应⽤于缓存⽅向。另外，redis 也经常⽤来做<code>分布式锁</code>。redis 提 供了多种数据类型来⽀持不同的业务场景。除此之外，redis ⽀持事务 、持久化、LUA脚本、LRU驱动 事件、多种集群⽅案。</p>
<h1>为什么要用 redis /为什么要用缓存</h1>
<p>主要从“<code>高性能</code>”和“<code>高并发</code>”这两点来看待这个问题。</p>
<h2>高性能</h2>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><figure><img data-width="729" data-height="469" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/6a09b66b66ab2e4e7f56d05a035372e6.webp" alt="" /></figure></p>
<h2>高并发</h2>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><figure><img data-width="554" data-height="469" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/5c917bb9d9fb7894344b3c1727d9e6ca.webp" alt="" /></figure></p>
<h2>为什么要⽤ redis ⽽不⽤ map/guava 做缓存?</h2>
<p>缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都 需要各⾃保存⼀份缓存，缓存不具有⼀致性。 使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓 存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。</p>
<h1>redis 的线程模型</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/m0_37524661/article/details/87086267">https://blog.csdn.net/m0_37524661/article/details/87086267</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1666100733546359034&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1666100733546359034&amp;wfr=spider&amp;for=pc</a></li>
</ul>
</blockquote>
<p><figure><img data-width="1546" data-height="628" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/5b855bc48530fe0b28a14f7d0d7f613c.png" alt="" /></figure></p>
<h2>redis单线程模型指的是什么</h2>
<p>Redis基于<code>Reactor</code>模式开发了网络事件处理器，这个处理器被称为<code>文件事件处理器</code>。它的组成结构为4部分：</p>
<blockquote><ul>
<li><p>多个套接字</p>
</li>
<li><p>IO多路复用程序</p>
</li>
<li><p>文件事件分派器</p>
</li>
<li><p>事件处理器</p>
</li>
</ul>
</blockquote>
<p>redis 内部使⽤⽂件事件处理器 <code>file event handler</code> ，这个<code>⽂件事件处理器</code>是<code>单线程</code>的，所以 redis 才叫做<code>单线程模型</code>。它采⽤ <code>IO 多路复⽤机</code>制同时监听多个 <code>socket</code>，根据 <code>socket</code> 上的事件 来选择对应的事件处理器进⾏处理</p>
<p>Redis客户端对服务端的每次调用都经历了<code>发送命令</code>，<code>执行命令</code>，<code>返回结果</code>三个过程。其中执行命令阶段，由于Redis是<code>单线程</code>来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行<code>顺序是不确定</code>的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p>
<blockquote><p>目前redis的网络处理方面时多线程，但是核心模块方面还是单线程</p>
</blockquote>
<h2>redis是单线程模型为什么效率还这么高？</h2>
<blockquote><ol>
<li><strong>纯内存访问</strong>：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li>
<li><strong>非阻塞I/O</strong>：Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</li>
<li>单线程避免了线程切换和竞态产生的消耗。</li>
<li>Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库</li>
</ol>
</blockquote>
<h2>rector模式简介</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/crazymakercircle/p/9833847.html">https://www.cnblogs.com/crazymakercircle/p/9833847.html</a></li>
</ul>
</blockquote>
<h2>为什么网络处理要引入多线程？</h2>
<p>之前的段落说了，Redis 的瓶颈并不在 CPU，而在<code>内存</code>和<code>网络I/O</code>。</p>
<p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p>
<p><figure><img data-width="600" data-height="400" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/1bb687254efee437331a4cbe63980e5a.jpg" alt="" /></figure></p>
<p><figure><img data-width="600" data-height="400" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/a01610012eec76c9bea5ec1a659e2e12.jpg" alt="" /></figure></p>
<h1>常⻅数据结构以及使⽤场景分析</h1>
<table>
<thead><tr>
<th>数据结构</th>
<th>常用命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>set,get,decr,incr,mget</td>
</tr>
<tr>
<td>Hash</td>
<td>hget,hset,hgetall</td>
</tr>
<tr>
<td>List</td>
<td>lpush,rpush,lpop,rpop,lrange</td>
</tr>
<tr>
<td>Set</td>
<td>sadd,spop,smembers,sunion</td>
</tr>
<tr>
<td>ZSet（Sorted Set）</td>
<td>zadd,zrange,zrem,zcard</td>
</tr>
</tbody>
</table>
<h2>String</h2>
<blockquote><p>常⽤命令: set,get,decr,incr,mget 等。</p>
</blockquote>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规keyvalue缓存应⽤； 常规计数：微博数，粉丝数等。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<h2>Hash</h2>
<blockquote><p>常⽤命令： hget,hset,hgetall 等。</p>
</blockquote>
<p>hash 是⼀个 string 类型的 <code>field</code> 和 <code>value</code> 的映射表，hash 特别适合⽤于存储对象，后续操作的时 候，你可以直接仅仅修改这个对象中的某个字段的值。 ⽐如我们可以 hash 数据结构来存储⽤户信 息，商品信息等等。⽐如下⾯我就⽤ hash 类型存放了我本⼈的⼀些信息：</p>
<div class="highlight"><pre><span></span><span class="err">key=JavaUser</span><span class="mi">293847</span>
<span class="err">value=</span><span class="p">{</span>
 <span class="err">“id”</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
 <span class="err">“</span><span class="kc">na</span><span class="err">me”</span><span class="p">:</span> <span class="err">“S</span><span class="kc">na</span><span class="err">ilClimb”</span><span class="p">,</span>
 <span class="err">“age”</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span>
 <span class="err">“loca</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">”</span><span class="p">:</span> <span class="err">“Wuha</span><span class="kc">n</span><span class="p">,</span> <span class="err">Hubei”</span>
<span class="p">}</span>
</pre></div>
<h2>List</h2>
<blockquote><p>常⽤命令: lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p>Redis list 的实现为⼀个<code>双向链表</code>。Redis list 的应⽤场景⾮常多，也是Redis最重要的数据结构之⼀，⽐如微博的关注 列表，粉丝列表，消息列表等功能都可以⽤Redis的 list 结构来实现。 Redis list 的实现为⼀个双向链表，即可以⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外 的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分⻚查询，这 个很棒的⼀个功能，基于 redis 实现简单的⾼性能分⻚，可以做类似微博那种下拉不断分⻚的东⻄ （⼀⻚⼀⻚的往下⾛），性能⾼。</p>
<p>在 key 对应 list 的头部添加字符串元素</p>
<div class="highlight"><pre><span></span><span class="n">lpush</span> <span class="n">name</span> <span class="n">value</span>
</pre></div>
<p>在 key 对应 list 的尾部添加字符串元素</p>
<div class="highlight"><pre><span></span><span class="n">rpush</span> <span class="n">name</span> <span class="n">value</span>
</pre></div>
<p>key 对应 list 中删除 count 个和 value 相同的元素</p>
<div class="highlight"><pre><span></span><span class="n">lrem</span> <span class="n">name</span> <span class="n">index</span>
</pre></div>
<p>返回 key 对应 list 的长度</p>
<div class="highlight"><pre><span></span><span class="n">llen</span> <span class="n">name</span>
</pre></div>
<h2>Set</h2>
<blockquote><p>常⽤命令： sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set 对外提供的功能与list类似是⼀个列表的功能，特殊之处在于 set 是可以⾃动排重的。 当你需要存储⼀个列表数据，⼜不希望出现重复数据时，set是⼀个很好的选择，并且set提供了判断某 个成员是否在⼀个set集合内的重要接⼝，这个也是list所不能提供的。可以基于 set 轻易实现交集、 并集、差集的操作。 ⽐如：在微博应⽤中，可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。 Redis可以⾮常⽅便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程， 具体命令如下：</p>
<div class="highlight"><pre><span></span><span class="err">si</span><span class="kc">nterst</span><span class="err">ore</span> <span class="err">key</span><span class="mi">1</span> <span class="err">key</span><span class="mi">2</span> <span class="err">key</span><span class="mi">3</span> <span class="err">将交集存在key</span><span class="mi">1</span><span class="err">内</span>
</pre></div>
<h2>ZSet（Sorted Set）</h2>
<blockquote><p>常⽤命令： zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>和set相⽐，sorted set增加了⼀个权重参数score，使得集合中的元素能够按score进⾏有序排列。 举例： 在直播系统中，实时排⾏信息包含直播间在线⽤户列表，各种礼物排⾏榜，弹幕消息（可以理 解为按消息维度的消息排⾏榜）等信息，适合使⽤ Redis 中的 Sorted Set 结构进⾏存储。</p>
<h1>Redis过期时间</h1>
<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。作为⼀个 缓存数据库，这是⾮常实⽤的。如我们⼀般项⽬中的 token 或者⼀些登录信息，尤其是短信验证码都 是有时间限制的，按照传统的数据库处理⽅式，⼀般都是⾃⼰判断过期，这样⽆疑会严重影响项⽬性 能。</p>
<p>我们 set key 的时候，都可以给⼀个 <code>expire time</code>，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。 也可以在运行时给存在的键设置剩余的生存时间，不设置则默认为<code>-1</code>，设置为-1时表示<code>永久存储</code>。</p>
<p>如果假设你创建一个 <code>Timer</code>，设置了⼀批 key 只能存活1个⼩时，那么接下来1⼩时后，redis是怎么对这批key进⾏删除 的？</p>
<blockquote><ul>
<li><strong>定期删除</strong>：redis默认是每隔 <code>100ms</code> 就随机抽取⼀些设置了过期时间的key，检查其是否过期， 如果过期就删除。注意这⾥是随机抽取的。为什么要随机呢？你想⼀想假如 redis 存了⼏⼗万 个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，这时候需要的是Cpu处理能力，而不是内存，就会给 CPU 带来很⼤的负载！ </li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那 个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！ 但是仅仅通过设置过期时间还是有问题的。</li>
</ul>
</blockquote>
<p>但是仅仅通过设置过期时间还是有问题的。我们想⼀下：如果定期删除漏掉了很多过期 key，然后你也 没及时去查，也就没⾛惰性删除，此时会怎么样？如果⼤量过期key堆积在内存⾥，导致redis内存块耗 尽了。怎么解决这个问题呢？ redis 内存淘汰机制。</p>
<h1>Redis内存淘汰机制</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/weixin_43184769/article/details/90523923">https://blog.csdn.net/weixin_43184769/article/details/90523923</a></li>
<li><a href="https://blog.csdn.net/qq_28018283/article/details/80764518">https://blog.csdn.net/qq_28018283/article/details/80764518</a></li>
<li>配置文件： <a href="http://download.redis.io/redis-stable/redis.conf">http://download.redis.io/redis-stable/redis.conf</a></li>
</ul>
</blockquote>
<p>思考一下，如果定期删除漏掉了很多过期的key，而我们也没有再去访问它，如果不加处理，很可能导致内存耗尽。</p>
<p>什么时候触发</p>
<p>Redis配置文件中可以设置<code>maxmemory</code>，内存的最大使用量，到达限度时会执行<code>内存淘汰机制</code></p>
<h2>内存置换策略</h2>
<p>没有配置时，<code>默认为no-eviction</code></p>
<table>
<thead><tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile-lru</td>
<td>从<code>已设置过期时间的数据集</code>中挑选<code>最近最少使用</code>的数据淘汰</td>
</tr>
<tr>
<td>volatile-lfu（4.0版本）</td>
<td>从<code>已设置过期时间的数据集</code>中挑选<code>最不经常</code>使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从<code>已设置过期时间的数据集</code>中挑选<code>将要过期</code>的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从<code>已设置过期时间的数据集</code>中挑选<code>任意数据</code>淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>当<code>内存不足</code>写入新数据时淘汰<code>最近最少</code>使用的Key</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>当<code>内存不足</code>写入新数据时<code>随机选择</code>key淘汰</td>
</tr>
<tr>
<td>allkeys-lfu（4.0版本）</td>
<td>当<code>内存不足</code>写入新数据时移除<code>最不经常使用</code>的Key</td>
</tr>
<tr>
<td>no-eviction（禁止驱逐数据）</td>
<td>当<code>内存不足</code>写入新数据时，写入操作会报错，同时不删除数据</td>
</tr>
</tbody>
</table>
<blockquote><ul>
<li>volatile为前缀的策略都是从已过期的数据集中进行淘汰。</li>
<li>allkeys为前缀的策略都是面向所有key进行淘汰。</li>
<li>LRU（least recently used）最少最近用到的。</li>
<li>LFU（Least Frequently Used）最不常用的。</li>
<li>TTL（Time To Live）</li>
<li>它们的触发条件都是Redis使用的内存达到阈值时。</li>
</ul>
</blockquote>
<h2>淘汰机制的实现</h2>
<p>既然是淘汰，那就需要把这些数据给删除，然后保存新的。Redis 删除失效主键的方法主要有两种：</p>
<h3>消极方法( passive way)</h3>
<p>在主键被访问时如果发现它已经失效,那么就删除它。 redis在实现<code>GET</code>、<code>MGET</code>、<code>HGET</code>、 LRANGE等所有涉及到读取数据的命令时都会调<code>expirelfNeeded</code>,它存在的意义就是在读取数据之前先检查一下它有没有失效,如果失效了就删除</p>
<p><code>expirelfNeeded</code>函数中调用的另外一个函数 <code>propagateExpire</code>,这个函数用来在正式删除<code>失效主键</code>,并且<code>广播</code>告诉其他地方,目的地有俩</p>
<blockquote><ul>
<li><code>AOF</code>文件,将删除失效主键的这一操作以 DEL Key的标准命令格式记录下来</li>
<li>另一个就是发送到当前 Redis服务器的所有 <code>Slave</code>,同样将删除失效主键的这操作以 <code>DEL Key</code>的标准命令格式告知这些<code>Slave</code>删除各自的失效主键</li>
</ul>
</blockquote>
<h3>积极方法( active way)</h3>
<p>周期性地探测,发现失效就删除。消极方法的缺点是,如果keγ迟迟不被访问,就会占用很多内存空间,所以才有积极方式</p>
<h3>主动删除</h3>
<p>当內存超过 <code>maxmemoryl</code>限定时,触发主动清理策略,该策略由启动参数的配置决定</p>
<h1>Redis持久化机制</h1>
<blockquote><p>怎么保证 redis 挂掉之后再重启数据可以进⾏恢复</p>
</blockquote>
<p>参考</p>
<blockquote><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc</a></li>
</ul>
</blockquote>
<p>很多时候我们需要持久化数据也就是将内存中的数据写⼊到硬盘⾥⾯，⼤部分原因是为了之后重⽤数据 （⽐如重启机器、机器故障之后恢复数据），或者是为了防⽌系统故障⽽将数据备份到⼀个远程位置。 Redis不同于Memcached的很重⼀点就是，Redis⽀持<code>持久化</code>，⽽且⽀持两种不同的持久化操作。</p>
<blockquote><ul>
<li>RDB（Redis DataBase 快照）</li>
<li>AOF（Append Only File）</li>
</ul>
</blockquote>
<h2>RDB（Redis DataBase 快照）</h2>
<p>Redis可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis创建快照之后，可 以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本（Redis主从结 构，主要⽤来提⾼Redis性能），还可以将快照留在原地以便重启服务器的时候使⽤。</p>
<p>优点</p>
<blockquote><ul>
<li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>
<li>在使用bgsave生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote><ul>
<li>RDB快照是一次<code>全量备份</code>，存储的是内存数据的<code>二进制序列化</code>形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的<code>内存数据</code>，父进程修改内存子进程<code>不会反应</code>出来，所以在<code>快照持久化期间修改的数据不会被保存</code>，可能丢失数据。</li>
</ul>
</blockquote>
<p>快照持久化是Redis<code>默认采⽤</code>的持久化⽅式,触发方式如下：</p>
<blockquote><ul>
<li>save</li>
<li>bgsave</li>
<li>自动化</li>
</ul>
</blockquote>
<h3>触发方式：save</h3>
<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>
<p><figure><img data-width="640" data-height="356" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/070dee4a1e209b4a551e32762fec5b15.jpg" alt="" /></figure></p>
<p>执行完成时候如果存在老的<code>RDB</code>文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
<h3>触发方式：bgsave</h3>
<p>执行该命令时，Redis会在后台<code>异步</code>进行快照操作，快照同时还可以<code>响应客户端请求</code>。具体流程如下：</p>
<p><figure><img data-width="640" data-height="337" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/76113d45a86cd56714ed45cc7d269887.jpg" alt="" /></figure></p>
<p>具体操作是Redis进程执行<code>fork</code>操作<code>创建子进程</code>，RDB持久化过程由<code>子进程负责</code>，完成后自动结束。阻塞只发生在<code>fork</code>阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 <code>bgsave</code> 命令。</p>
<h3>触发方式：自动触发</h3>
<p>自动触发是由我们的配置文件来完成的。在<code>redis.conf</code>配置文件中，里面有如下配置，我们可以去设置：</p>
<p><strong>①save</strong></p>
<p>这里是用来配置触发 Redis的 <code>RDB</code> 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发<code>bgsave</code>。</p>
<p>默认如下配置：</p>
<div class="highlight"><pre><span></span><span class="n">save</span> <span class="n">m</span> <span class="n">n</span>

<span class="err">#</span><span class="n">在900秒</span><span class="p">(</span><span class="mi">15</span><span class="n">分钟</span><span class="p">)</span><span class="n">之后</span><span class="err">，</span><span class="n">如果</span><span class="err">⾄</span><span class="n">少有1个key发</span><span class="err">⽣</span><span class="n">变化</span><span class="err">，</span><span class="n">Redis就会</span><span class="err">⾃</span><span class="n">动触发BGSAVE命令创建快照</span><span class="err">。</span>
<span class="n">save</span> <span class="mi">900</span> <span class="mi">1</span> 

<span class="err">#</span><span class="n">在300秒</span><span class="p">(</span><span class="mi">5</span><span class="n">分钟</span><span class="p">)</span><span class="n">之后</span><span class="err">，</span><span class="n">如果</span><span class="err">⾄</span><span class="n">少有10个key发</span><span class="err">⽣</span><span class="n">变化</span><span class="err">，</span><span class="n">Redis就会</span><span class="err">⾃</span><span class="n">动触发BGSAVE命令创建快照</span><span class="err">。</span>
<span class="n">save</span> <span class="mi">300</span> <span class="mi">10</span> 

<span class="err">#</span><span class="n">在60秒</span><span class="p">(</span><span class="mi">1</span><span class="n">分钟</span><span class="p">)</span><span class="n">之后</span><span class="err">，</span><span class="n">如果</span><span class="err">⾄</span><span class="n">少有10000个key发</span><span class="err">⽣</span><span class="n">变化</span><span class="err">，</span><span class="n">Redis就会</span><span class="err">⾃</span><span class="n">动触发BGSAVE命令创建快照</span><span class="err">。</span>
<span class="n">save</span> <span class="mi">60</span> <span class="mi">10000</span>
</pre></div>
<p><strong>②stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p>
<p><strong>③rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p>
<p><strong>④rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
<p><strong>⑤dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p>
<p><strong>⑥dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p>
<h3>save和bgsave的区别</h3>
<p><figure><img data-width="640" data-height="277" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/85ba179062e425e4a80283d1bcbd000e.jpg" alt="" /></figure></p>
<h2>AOF（Append Only File）</h2>
<p>与<code>快照持久化</code>相⽐，<code>AOF持久化</code> 的<code>实时性</code>更好，因此已成为主流的持久化⽅案。默认情况下Redis没有 开启<code>AOF（append only file）</code>⽅式的持久化。</p>
<p>可以通过<code>appendonly</code>参数开启：</p>
<h3>持久化原理</h3>
<p><figure><img data-width="640" data-height="322" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/9f1bd6d7ebccedcffc5286d43fb7c0e0.jpg" alt="" /></figure></p>
<p>每当有一个写命令过来时，就直接保存在我们的<code>AOF</code>文件中。</p>
<h3>文件重写原理</h3>
<p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩<code>AOF</code>的持久化文件。redis提供了<code>bgrewriteaof</code>命令。将内存中的数据以命令的方式保存到临时文件中，同时会<code>fork</code>出一条<code>新进程</code>来将文件重写。</p>
<p><figure><img data-width="640" data-height="286" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/1ee6baafe21dfd33aa375f440d4ee67d.jpg" alt="" /></figure></p>
<p>重写<code>AOF</code>文件的操作，并没有读取旧的<code>AOF</code>文件，而是将整个内存中的数据库内容用命令的方式重写了一个<code>新的AOF文件</code>，这点和<code>快照</code>有点类似。</p>
<div class="highlight"><pre><span></span><span class="n">appendonly</span> <span class="n">yes</span>
</pre></div>
<p>开启AOF持久化后每执⾏⼀条会更改Redis中的数据的命令，Redis就会将该命令通过<code>write</code>写⼊硬盘中的<code>AOF</code>⽂件，通俗的理解就是<code>日志记录</code>。 <code>AOF</code>⽂件的保存位置和<code>RDB</code>⽂件的位置相同，都是通过<code>dir</code>参数设置的，默认的⽂件名是 <code>appendonly.aof</code>。</p>
<div class="highlight"><pre><span></span><span class="n">appendfsync</span> <span class="n">always</span> <span class="err">#</span><span class="n">每次有数据修改发</span><span class="err">⽣</span><span class="n">时都会写</span><span class="err">⼊</span><span class="n">AOF</span><span class="err">⽂</span><span class="n">件</span><span class="p">,</span><span class="n">这样会严重降低Redis的速度</span>

<span class="n">appendfsync</span> <span class="n">everysec</span> <span class="err">#</span><span class="n">每秒钟同步</span><span class="err">⼀</span><span class="n">次</span><span class="err">，</span><span class="n">显示地将多个写命令同步到硬盘</span>

<span class="n">appendfsync</span> <span class="n">no</span> <span class="err">#</span><span class="n">让操作系统决定何时进</span><span class="err">⾏</span><span class="n">同步</span>
</pre></div>
<p>为了兼顾数据和写⼊性能，⽤户可以考虑 <code>appendfsync everysec</code>选项 ，让Redis每秒同步⼀次AOF⽂ 件，Redis性能⼏乎没受到任何影响。⽽且这样即使出现系统崩溃，⽤户最多只会丢失⼀秒之内产⽣的 数据。当硬盘忙于执⾏写⼊操作的时候，Redis还会优雅的放慢⾃⼰的速度以便适应硬盘的最⼤写⼊速度。</p>
<h2>Redis 4.0 对于持久化机制的优化</h2>
<p>Redis 4.0 开始⽀持 <code>RDB</code> 和 <code>AOF</code> 的<code>混合持久化</code>（默认关闭，可以通过配置项开启）</p>
<div class="highlight"><pre><span></span><span class="n">aof</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">rdbpreamble</span>
</pre></div>
<p>如果把混合持久化打开，<code>AOF</code> 重写的时候就直接把 <code>RDB</code> 的内容写到 <code>AOF ⽂件开头</code>。这样做的好处是可 以结合 <code>RDB</code> 和 <code>AOF</code> 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， <code>AOF</code> ⾥⾯的 <code>RDB</code> 部分是压缩格式不再是 <code>AOF</code> 格式，可读性较差。</p>
<h1>Redis事务</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-transactions.html">https://www.runoob.com/redis/redis-transactions.html</a></li>
</ul>
</blockquote>
<p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code> 等命令来实现<code>事务(transaction)</code>功能。Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<h2>特点</h2>
<blockquote><ul>
<li>Redis事务没有隔离级别的概念：批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</li>
<li>Redis事务不保证原子性：Redis中，<code>单条命令是原子性执行的</code>，但事务不保证<code>原子性</code>，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
</blockquote>
<h2>阶段</h2>
<blockquote><ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
</blockquote>
<h2>相关命令参考</h2>
<blockquote><ul>
<li><a href="https://www.runoob.com/redis/redis-transactions.html">https://www.runoob.com/redis/redis-transactions.html</a></li>
</ul>
</blockquote>
<h1>缓存雪崩 | 缓存穿透 | 缓存击穿</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://blog.csdn.net/fanrenxiang/article/details/80542580">https://blog.csdn.net/fanrenxiang/article/details/80542580</a></li>
<li><a href="https://www.cnblogs.com/xichji/p/11286443.html">https://www.cnblogs.com/xichji/p/11286443.html</a></li>
</ul>
<ul>
<li><strong>缓存穿透</strong>：key对应的数据在数据源并不存在，每次针对此key的请求从<code>缓存</code>获取不到，请求都会到<code>数据源</code>，从而可能<code>压垮数据源</code>。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库，若黑客利用此漏洞进行攻击可能压垮数据库。</li>
<li><strong>缓存击穿</strong>：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个<code>key</code>在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，这个时候大并发的请求可能会瞬间把后端DB压垮，就像在一个屏障上凿开了一个洞。</li>
<li><strong>缓存雪崩</strong>：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</li>
</ul>
</blockquote>
<h2>缓存穿透</h2>
<p>缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有 经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库。</p>
<h3>原理</h3>
<p>正常缓存处理流程</p>
<p><figure><img data-width="772" data-height="790" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/e850c5479e8633d745652cb429297f9a.jpg" alt="" /></figure></p>
<p>缓存穿透处理流程</p>
<p><figure><img data-width="738" data-height="787" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/17f07d5544e76b28c320f700c2f494d8.jpg" alt="" /></figure></p>
<h3>解决办法</h3>
<p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>最基本的就是⾸先做好<code>参数校验</code>，⼀些<code>不合法的参数</code>请求直接抛出异常信息返回给客户端。⽐如查询的 数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObjectInclNullById</span><span class="p">(</span><span class="n">Integer</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// 从缓存中获取数据</span>
 <span class="n">Object</span> <span class="n">cacheValue</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
 <span class="c1">// 缓存为空</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">cacheValue</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// 从数据库中获取</span>
 <span class="n">Object</span> <span class="n">storageValue</span> <span class="o">=</span> <span class="n">storage</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
 <span class="c1">// 缓存空对象</span>
 <span class="n">cache</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">storageValue</span><span class="p">);</span>
 <span class="c1">// 如果存储数据为空，需要设置⼀个过期时间(300秒)</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">storageValue</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// 必须设置过期时间，否则有被攻击的⻛险</span>
 <span class="n">cache</span><span class="p">.</span><span class="na">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="n">storageValue</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="n">cacheValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3>布隆过滤器（bloom filter）</h3>
<p>参考</p>
<blockquote><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</a></li>
</ul>
</blockquote>
<p>布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数 据是否存在与海量数据中。我们需要的就是判断 <code>key</code> 是否合法，有没有感觉布隆过滤器就是我们想要 找的那个“⼈”。具体是这样做的：把<code>所有可能存在的请求的值</code>都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信 息给客户端，存在的话才会⾛下⾯的流程。</p>
<p><figure><img data-width="757" data-height="934" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/cb0129d9bb302199a18c332e934edea3.jpg" alt="" /></figure></p>
<h2>缓存击穿</h2>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/chengege/p/11073166.html">https://www.cnblogs.com/chengege/p/11073166.html</a></li>
</ul>
</blockquote>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<h3>互斥锁(mutex key)</h3>
<p>业界比较常用的做法，是使用<code>mutex</code>。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去<code>load db</code>，而是先使用缓存工具的某些带成功操作返回值的操作（比如<code>Redis</code>的<code>SETNX</code>或者<code>Memcache</code>的<code>ADD</code>）去<code>set</code>一个<code>mutex key</code>，当操作返回成功时，再进行<code>load db</code>的操作并<code>回设缓存</code>；否则，就重试整个<code>get</code>缓存的方法。就是只让一个线程构建<code>缓存</code>，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了。</p>
<p><figure><img data-width="384" data-height="336" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/c9f36956bf690cf2a3e9ab93779375af.png" alt="" /></figure></p>
<h2>缓存雪崩</h2>
<p>简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤ 量请求⽽崩掉。</p>
<blockquote><ul>
<li>事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策 略。 </li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 </li>
<li>事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<ul>
<li>设置key永不失效（热点数据）；</li>
<li>设置key缓存失效时候尽可能错开；</li>
<li>使用多级缓存机制，比如同时使用redsi和memcache缓存，请求-&gt;redis-&gt;memcache-&gt;db；</li>
<li>购买第三方可靠性高的Redis云服务器；</li>
</ul>
</blockquote>
<p><figure><img data-width="1482" data-height="921" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/3113f61e5fdcd5a4ec713c4c68ef7e95.jpg" alt="" /></figure></p>
<h1>如何解决 Redis 的并发竞争 Key 问题</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.jianshu.com/p/41d3a673425d">https://www.jianshu.com/p/41d3a673425d</a></li>
<li><a href="https://blog.csdn.net/qq_42253147/article/details/94446727">https://blog.csdn.net/qq_42253147/article/details/94446727</a></li>
</ul>
</blockquote>
<p>这里的并发指的是多个redis的client同时set key引起的并发问题，也就是多个系统同时对⼀个 key 进⾏操作，但是最后执⾏的顺序 和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>方案</p>
<blockquote><ul>
<li><strong>分布式锁+时间戳</strong></li>
<li><strong>消息队列MQ</strong></li>
</ul>
</blockquote>
<h2>分布式锁+时间戳</h2>
<h3>如果对这个key操作，不要求顺序</h3>
<p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做<code>set</code>操作即可，比较简单。加锁的目的实际上就是把<code>并行读写</code>改成<code>串行读写</code>的方式，从而来避免资源竞争。</p>
<h3>如果对这个key操作，要求顺序</h3>
<p>假设有一个<code>key1</code></p>
<blockquote><ul>
<li>系统A需要将key1设置为valueA</li>
<li>系统B需要将key1设置为valueB</li>
<li>系统C需要将key1设置为valueC</li>
</ul>
</blockquote>
<p>期望按照key1的value值按照 <code>valueA–&gt;valueB–&gt;valueC</code>的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个<code>时间戳</code>。假设<code>时间戳</code>如下</p>
<blockquote><ul>
<li>系统A key 1 {valueA 3:00}</li>
<li>系统B key 1 {valueB 3:05}</li>
<li>系统C key 1 {valueC 3:10}</li>
</ul>
</blockquote>
<p>那么，假设这会<code>系统B</code>先抢到锁，将<code>key1</code>设置为<code>{valueB 3:05}</code>。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做<code>set</code>操作了。以此类推</p>
<h3>什么是分布式锁</h3>
<p>因为传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。</p>
<p>当然，分布式锁可以基于很多种方式实现，比如zookeeper、redis等，</p>
<p>不管哪种方式实现，基本原理是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识</strong>。</p>
<h3>分布式锁的实现</h3>
<p>主要用到的redis函数是<code>setnx()</code></p>
<p>利用<code>SETNX</code>非常简单地实现<code>分布式锁</code>。例如：某客户端要获得一个名字<code>youzhi</code>的锁，客户端使用下面的命令进行获取：</p>
<div class="highlight"><pre><span></span>SETNX lock.youzhi&lt;current Unix <span class="nb">time</span> + lock timeout + <span class="m">1</span>&gt;
</pre></div>
<blockquote><ul>
<li>如返回1，则该客户端获得锁，把<code>lock.youzhi</code>的键值设置为时间值表示该键已被锁定，该客户端最后可以通过<code>DEL lock.foo</code>来释放该锁。</li>
<li>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li>
</ul>
</blockquote>
<h2>消息队列</h2>
<p>在并发量过大的情况下,可以通过<code>消息中间件</code>进行处理,把<code>并行读写</code>进行<code>串行化</code>。</p>
<p>把<code>Redis.set</code>操作放在队列中使其串行化,必须的一个一个执行。</p>
<p>这种方式在一些高并发的场景中算是一种通用的解决方案。</p>
<h1>区别</h1>
<h2>redis 和 memcached 的区别</h2>
<blockquote><ol>
<li><strong>redis⽀持更丰富的数据类型（⽀持更复杂的应⽤场景）</strong>：Redis不仅仅⽀持简单的k/v类型的数 据，同时还提供list，set，zset，hash等数据结构的存储。memcache⽀持简单的数据类型， String。 </li>
<li><strong>Redis⽀持数据的持久化</strong>：可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使 ⽤,⽽Memecache把数据全部存在内存之中。 </li>
<li><strong>集群模式</strong>：memcached没有原⽣的集群模式，需要依靠客户端来实现往集群中分⽚写⼊数据；但 是 redis ⽬前是原⽣⽀持 cluster 模式的. </li>
<li>Memcached是多线程，⾮阻塞IO复⽤的⽹络模型；Redis使⽤单线程的多路 IO 复⽤模型。</li>
</ol>
</blockquote>
<p><figure><img data-width="1207" data-height="741" src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/archives/assets/f67a0c75bb3b9fb63323c66f68e5f3cd.jpg" alt="" /></figure></p>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/SQL学习笔记/">
                    <time>October 12 2020</time>
                    <span>SQL学习笔记</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/Swagger使用/">
                    <time>October 10 2020</time>
                    <span>Swagger使用</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u7565\u61c2"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 ze</span>
                        
    <span class="leancloud_visitors"
            id="/archives/Redis理论学习笔记/" 
            data-flag-title="Redis理论学习笔记">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/ze/Wiki@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>